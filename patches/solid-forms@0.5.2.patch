diff --git a/dist/core/index.common.js b/dist/core/index.common.js
index d72a62323d6654af795a0262a3b14d320210160d..b0e795fa8f18175fce99df041a61991bab940160 100644
--- a/dist/core/index.common.js
+++ b/dist/core/index.common.js
@@ -4,7 +4,7 @@ Object.defineProperty(exports, '__esModule', { value: true });
 
 var store = require('solid-js/store');
 var solidJs = require('solid-js');
-var _isEqual = require('fast-deep-equal/es6');
+var _isEqual = require('deep-equal');
 
 function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }
 
diff --git a/dist/core/index.common.js.map b/dist/core/index.common.js.map
index e9de3d2c0fd96d392a990b557d0840e33fd936a9..e9b8dc27e60f04aaf6efffeb562ed979ea20a6c0 100644
--- a/dist/core/index.common.js.map
+++ b/dist/core/index.common.js.map
@@ -1 +1 @@
-{"version":3,"file":"index.common.js","sources":["../../src/abstract-control.ts","../../src/abstract-control-container.ts","../../src/util.ts","../../src/abstract-control-base.ts","../../src/form-control.ts","../../src/abstract-control-container-base.ts","../../src/form-group.ts","../../src/form-array.ts"],"sourcesContent":["// *****************************\n// Misc Types\n// *****************************\n\nexport type ControlId = string | symbol;\n\nexport type ValidatorFn<T = any> = (rawValue: T) => ValidationErrors | null;\n\nexport interface ValidationErrors {\n  [key: string]: any;\n}\n\n// *****************************\n// AbstractControl interface\n// *****************************\n\nexport const AbstractControlInterface = '@@AbstractControlInterface_solidjs';\n\n/** Returns true if the provided object implements `IAbstractControl` */\nexport function isAbstractControl(\n  object?: unknown\n): object is IAbstractControl {\n  return (\n    typeof object === 'object' &&\n    (object as any)?.[AbstractControlInterface] === true\n  );\n}\n\nexport interface IAbstractControl<\n  RawValue = any,\n  Data extends Record<ControlId, any> = Record<ControlId, any>,\n  Value = RawValue\n> {\n  /**\n   * The ID is used to determine where StateChanges originated,\n   * and to ensure that a given AbstractControl only processes\n   * values one time.\n   */\n  readonly id: ControlId;\n\n  /**\n   * The data property can store arbitrary custom data. Use the\n   * `setData` method on `IAbstractControl` to update it.\n   *\n   * The `data` property is, itself, an object. You can set individual\n   * keys on the data property with `setData` but you cannot reset\n   * or clear the whole object. This is intentional. A library\n   * maintainer can store private data within the `data` property\n   * using a symbol without fear of the user accidently erasing it.\n   */\n  readonly data: Data;\n\n  /**\n   * The value of the IAbstractControl.\n   *\n   * In an IAbstractControlContainer,\n   * `value` and `rawValue` can be different, but in a standard\n   * `IAbstractControl` `value` is just an alias for `rawValue`.\n   * See the IAbstractControlContainer interface for possible differences\n   * between `value` and `rawValue`.\n   */\n  readonly value: Value;\n\n  /**\n   * The value of the IAbstractControl.\n   *\n   * In an IAbstractControlContainer,\n   * `value` and `rawValue` can be different, but in a standard\n   * `IAbstractControl` `value` is just an alias for `rawValue` and\n   * rawValue just contains the control's value.\n   * See the IAbstractControlContainer interface for possible differences\n   * between `value` and `rawValue`.\n   */\n  readonly rawValue: RawValue;\n\n  /**\n   * `true` if this control is disabled, false otherwise.\n   * This is an alias for `self.isDisabled`.\n   */\n  readonly isDisabled: boolean;\n\n  /**\n   * `true` if this control is touched, false otherwise.\n   * This is an alias for `self.isTouched`.\n   */\n  readonly isTouched: boolean;\n\n  /**\n   * `true` if this control is dirty, false otherwise.\n   * This is an alias for `self.isDirty`.\n   */\n  readonly isDirty: boolean;\n  /**\n   * `true` if this control is readonly, false otherwise.\n   * This is an alias for `self.isReadonly`.\n   */\n  readonly isReadonly: boolean;\n  /**\n   * `true` if this control is submitted, false otherwise.\n   * This is an alias for `self.isSubmitted`.\n   */\n  readonly isSubmitted: boolean;\n  /**\n   * `true` if this control is required, false otherwise.\n   * This is an alias for `self.isRequired`.\n   *\n   * Note that this property doesn't\n   * have any predefined meaning for IAbstractControls and it doesn't affect\n   * validation in any way. It is up to you to decide what meaning, if any,\n   * to give to this property and how to use it. For example, if you\n   * validated the control inside a `createEffect()`, you could choose to alter the\n   * validation based on whether the control was marked as `required` or\n   * not.\n   */\n  readonly isRequired: boolean;\n\n  /**\n   * Contains a `ValidationErrors` object if this control\n   * has any errors. Otherwise contains `null`.\n   *\n   * An alias for `self.errors`.\n   */\n  readonly errors: ValidationErrors | null;\n\n  /**\n   * A validator function that is run on rawValue changes and which\n   * generates errors associated with the source \"CONTROL_DEFAULT_SOURCE\".\n   */\n  readonly validator: ValidatorFn | null;\n\n  /**\n   * `true` if this control is pending, false otherwise.\n   * This is an alias for `self.isPending`.\n   */\n  readonly isPending: boolean;\n\n  /**\n   * Valid if `errors === null && !isPending`\n   *\n   * This is an alias for `self.valid`.\n   */\n  readonly isValid: boolean;\n\n  /**\n   * The `self` object on an abstract control contains\n   * properties reflecting the control's personal state. On an\n   * IAbstractControlContainer, the personal state can differ\n   * from the control's state. For example, an\n   * IAbstractControlContainer will register as disabled if\n   * the control itself has been marked as disabled OR if\n   * all of it's child controls are disabled.\n   *\n   * Marking the control container\n   * itself as disabled doesn't mark the container's children as\n   * disabled. On a standard IAbstractControl though,\n   * the \"self\" properties are the same as regular properties.\n   * I.e. `self.isInvalid` is the same as `isInvalid` on a\n   * standard IAbstractControl (actually, `isInvalid` is\n   * an alias for `self.isInvalid` on a standard control).\n   */\n  readonly self: {\n    /** `this.self.errors === null && !this.self.isPending` */\n    readonly isValid: boolean;\n\n    /** `true` if this control is disabled, false otherwise. */\n    readonly isDisabled: boolean;\n\n    /** `true` if this control is touched, false otherwise. */\n    readonly isTouched: boolean;\n\n    /**\n     * `true` if this control is dirty, false otherwise.\n     *\n     * Dirty can be thought of as, \"Has the value changed?\"\n     * Though the isDirty property must be manually set by\n     * the user (using `markDirty()`) and is not automatically\n     * updated.\n     */\n    readonly isDirty: boolean;\n    /**\n     * `true` if this control is readonly, false otherwise.\n     *\n     * This property does not have any predefined meeting for\n     * an IAbstractControl. You can decide if you want to give\n     * it meaning by, for example, using this value to set\n     * an input's readonly status (e.g.\n     * `<input readonly={control.isReadonly} />`)\n     */\n    readonly isReadonly: boolean;\n\n    /** `true` if this control is submitted, false otherwise. */\n    readonly isSubmitted: boolean;\n\n    /**\n     * `true` if this control is required, false otherwise.\n     *\n     * Note that this property doesn't\n     * have any predefined meaning for IAbstractControls and it doesn't affect\n     * validation in any way. It is up to you to decide what meaning, if any,\n     * to give to this property and how to use it. For example, if you\n     * validated the control inside a `createEffect()` you could alter the\n     * validation based on whether the control was marked as `required` or\n     * not.\n     */\n    readonly isRequired: boolean;\n\n    /** `true` if this control is pending, false otherwise. */\n    readonly isPending: boolean;\n\n    /**\n     * Contains a `ValidationErrors` object if this control\n     * has any errors. Otherwise contains `null`.\n     */\n    readonly errors: ValidationErrors | null;\n\n    /**\n     * *More advanced-ish*\n     *\n     * Contains a map of ControlId values and ValidationErrors.\n     * The errorsStore allows partitioning errors so that\n     * they can be associated with different sources and so\n     * that one source does not overwrite another source.\n     *\n     * The `self.errors` property gets its errors from the errorsStore.\n     */\n    readonly errorsStore: ReadonlyMap<ControlId, ValidationErrors>;\n\n    /**\n     * More advanced-ish*\n     *\n     * A set of ControlIds. `self.isPending` is true so long\n     * as `pendingStore.size > 0`. Because this is a set, you\n     * can track multiple pending \"things\" at once. This\n     * control will register as pending until all of the \"things\"\n     * have resolved. Use the `markPending()` method with\n     * the `source` option to update the pendingStore.\n     */\n    readonly pendingStore: ReadonlySet<ControlId>;\n\n    /**\n     * More advanced-ish*\n     *\n     * A map of ControlIds and ValidatorFns. The `validator`\n     * property is composed of all the validator functions in the\n     * `validatorStore`. The validatorStore allows you to change\n     * individual validator functions on the control without\n     * affecting other validator functions on the control.\n     *\n     * When you use the `setValidators` method, you are updating\n     * the validatorStore.\n     */\n    readonly validatorStore: ReadonlyMap<ControlId, ValidatorFn>;\n  };\n\n  /**\n   * If this control is disabled, the status is `\"DISABLED\"`,\n   * else if this control is pending, the status is `\"PENDING\"`,\n   * else if this control has any errors, the status is `\"INVALID\"`,\n   * else the status is `\"VALID\"`.\n   */\n  readonly status: 'DISABLED' | 'PENDING' | 'INVALID' | 'VALID';\n\n  [AbstractControlInterface]: true;\n\n  /** set the control's value  */\n  setValue(value: RawValue): void;\n\n  /**\n   * If provided a `ValidationErrors` object or `null`, replaces `self.errors`.\n   * Optionally, provide a source ID and the change will be partitioned\n   * assocaited with the source ID. The default source ID is\n   * \"CONTROL_DEFAULT_SOURCE\".\n   *\n   * If you provide a `Map` object containing `ValidationErrors` keyed to source IDs,\n   * that will replace the `self.errorsStore` associated with this control.\n   */\n  setErrors(\n    value: ValidationErrors | null | ReadonlyMap<ControlId, ValidationErrors>,\n    options?: { source?: ControlId }\n  ): void;\n\n  /**\n   * If you provide a `ValidationErrors` object, that object is merged with the\n   * existing errors associated with the source ID. If the error object has\n   * keys equal to `null`, errors associated with those keys are deleted\n   * from the errors object.\n   *\n   * If you provide a `Map` object containing `ValidationErrors` keyed to source IDs,\n   * that object is merged with the existing `errorsStore`.\n   */\n  patchErrors(\n    value: ValidationErrors | ReadonlyMap<ControlId, ValidationErrors>,\n    options?: { source?: ControlId }\n  ): void;\n\n  /** sets `self.isTouched` */\n  markTouched(value: boolean): void;\n\n  /** sets `self.isDirty` */\n  markDirty(value: boolean): void;\n\n  /** sets `self.isReadonly` */\n  markReadonly(value: boolean): void;\n\n  /**\n   * Sets `self.isRequired`.\n   *\n   * Note that this property doesn't\n   * have any predefined meaning for IAbstractControls and it doesn't affect\n   * validation in any way. It is up to you to decide what meaning, if any,\n   * to give to this property and how to use it. For example, if you\n   * validated the control inside a `createEffect()` you could alter the\n   * validation based on whether the control was marked as `required` or\n   * not.\n   */\n  markRequired(value: boolean): void;\n\n  /**\n   * Set `self.isDisabled`.\n   *\n   * Note that `self.isDisabled`` affect's the control's `status`\n   * property. Additionally, `IAbstractControlContainer's` ignore\n   * disabled children in many cases. For example, the `value` of a\n   * control container is equal to the value of it's _enabled_ children\n   * (if you want to see the value including disabled children, use\n   * `rawValue`).\n   */\n  markDisabled(value: boolean): void;\n\n  /** sets `self.isSubmitted` */\n  markSubmitted(value: boolean): void;\n\n  /** sets `self.pendingStore` and `self.isPending` */\n  markPending(\n    value: boolean | ReadonlySet<ControlId>,\n    options?: { source?: ControlId }\n  ): void;\n\n  /** sets `validator` and `self.validatorStore` */\n  setValidators(\n    value:\n      | ValidatorFn\n      | ValidatorFn[]\n      | ReadonlyMap<ControlId, ValidatorFn>\n      | null,\n    options?: { source?: ControlId }\n  ): void;\n\n  /**\n   * The data property can store arbitrary custom data. Use the\n   * `setData` method on `IAbstractControl` to update it.\n   *\n   * The `data` property is, itself, an object. You can set individual\n   * keys on the data property with `setData` but you cannot reset\n   * or clear the whole object. This is intentional. A library\n   * maintainer can store private data within the `data` property\n   * using a symbol without fear of the user accidently erasing it.\n   */\n  setData<K extends keyof Data>(key: K, data: Data[K]): void;\n}\n","import {\n  ControlId,\n  isAbstractControl,\n  ValidationErrors,\n} from './abstract-control';\nimport { IAbstractControl } from './abstract-control';\n\n// UTILITY TYPES\n\ntype PickUndefinedKeys<T> = {\n  [K in keyof T]: undefined extends T[K] ? K : never;\n}[keyof T];\n\ntype PickRequiredKeys<T> = {\n  [K in keyof T]: undefined extends T[K] ? never : K;\n}[keyof T];\n\ntype ObjectControlsOptionalRawValue<\n  T extends { [key: string]: IAbstractControl | undefined }\n> = {\n  [P in Exclude<PickUndefinedKeys<T>, undefined>]?: NonNullable<\n    T[P]\n  >['rawValue'];\n};\n\ntype ObjectControlsRequiredRawValue<\n  T extends { [key: string]: IAbstractControl | undefined }\n> = {\n  [P in Exclude<PickRequiredKeys<T>, undefined>]: NonNullable<T[P]>['rawValue'];\n};\n\ntype ArrayControlsRawValue<T extends ReadonlyArray<IAbstractControl>> =\n  T extends ReadonlyArray<infer C>\n    ? C extends IAbstractControl\n      ? ReadonlyArray<C['rawValue']>\n      : never\n    : never;\n\ntype ObjectControlsOptionalValue<\n  T extends { [key: string]: IAbstractControl | undefined }\n> = {\n  [P in Exclude<PickUndefinedKeys<T>, undefined>]?: NonNullable<T[P]>['value'];\n};\n\ntype ObjectControlsRequiredValue<\n  T extends { [key: string]: IAbstractControl | undefined }\n> = {\n  [P in Exclude<PickRequiredKeys<T>, undefined>]: NonNullable<T[P]>['value'];\n};\n\ntype ArrayControlsValue<T extends ReadonlyArray<IAbstractControl>> =\n  T extends ReadonlyArray<infer C>\n    ? C extends IAbstractControl\n      ? ReadonlyArray<C['value']>\n      : never\n    : never;\n\n// END UTILITY TYPES\n\nexport type GenericControlsObject =\n  | {\n      readonly [key: string]: IAbstractControl;\n    }\n  | ReadonlyArray<IAbstractControl>;\n\n// need to add the `keyof ControlsRawValue<Controls>` as well as\n// `keyof ControlsValue<Controls>` as well as the `keyof Controls` etc\n// because typescript doesn't realize that all three are the same keys\n// and without all three, then ControlsKey can't be used to index all three\nexport type ControlsKey<Controls extends GenericControlsObject> =\n  keyof ControlsRawValue<Controls> &\n    keyof ControlsValue<Controls> &\n    (Controls extends ReadonlyArray<any>\n      ? keyof Controls & number\n      : Controls extends object\n      ? // the `& string` is needed or else\n        // ControlsKey<{[key: string]: AbstractControl}> is type string | number\n        keyof Controls & string\n      : any);\n\nexport type ControlsRawValue<Controls extends GenericControlsObject> =\n  Controls extends ReadonlyArray<IAbstractControl>\n    ? ArrayControlsRawValue<Controls>\n    : Controls extends { readonly [key: string]: IAbstractControl | undefined }\n    ? ObjectControlsRequiredRawValue<Controls> &\n        ObjectControlsOptionalRawValue<Controls>\n    : never;\n\nexport type ControlsValue<Controls extends GenericControlsObject> =\n  Controls extends ReadonlyArray<IAbstractControl>\n    ? ArrayControlsValue<Controls>\n    : Controls extends { readonly [key: string]: IAbstractControl | undefined }\n    ? Partial<\n        ObjectControlsRequiredValue<Controls> &\n          ObjectControlsOptionalValue<Controls>\n      >\n    : never;\n\nexport type ContainerControls<C> = C extends IAbstractControlContainer<\n  infer Controls\n>\n  ? Controls\n  : unknown;\n\nexport const AbstractControlContainerInterface =\n  '@@AbstractControlContainerInterface_solidjs';\n\n/**\n * Returns true if the provided object implements\n * `IAbstractControlContainer`\n */\nexport function isAbstractControlContainer(\n  object?: unknown\n): object is IAbstractControlContainer {\n  return (\n    isAbstractControl(object) &&\n    (object as any)[AbstractControlContainerInterface]\n  );\n}\n\nexport interface IAbstractControlContainer<\n  Controls extends GenericControlsObject = any,\n  Data = any\n> extends IAbstractControl<\n    ControlsRawValue<Controls>,\n    Data,\n    ControlsValue<Controls>\n  > {\n  /** Child controls associated with this container */\n  readonly controls: Controls;\n\n  /** The number of controls associated with this container */\n  readonly size: number;\n\n  /** Only returns values for enabled child controls. */\n  readonly value: ControlsValue<Controls>;\n\n  /**\n   * Returns values for both enabled and disabled child controls.\n   */\n  readonly rawValue: ControlsRawValue<Controls>;\n\n  /** Will return true if `this.self.isValid` and `this.children.areValid` */\n  readonly isValid: boolean;\n\n  /** Will return true if `this.self.isDisabled` or `this.children.areDisabled` */\n  readonly isDisabled: boolean;\n\n  /** Will return true if `this.self.isReadonly` or `this.children.areReadonly` */\n  readonly isReadonly: boolean;\n\n  /** Will return true if `this.self.isRequired` or `this.child.isRequired` */\n  readonly isRequired: boolean;\n\n  /** Will return true if `this.self.isPending` or `this.child.isPending` */\n  readonly isPending: boolean;\n\n  /** Will return true if `this.self.isTouched` or `this.child.isTouched` */\n  readonly isTouched: boolean;\n\n  /** Will return true if `this.self.isDirty` or `this.child.isDirty` */\n  readonly isDirty: boolean;\n\n  /** Will return true if `this.self.isSubmitted` or `this.children.areSubmitted` */\n  readonly isSubmitted: boolean;\n\n  /** Contains `{ ...this.children.errors, ...this.self.errors }` or `null` if there are none */\n  readonly errors: ValidationErrors | null;\n\n  readonly child: {\n    /** Will return true if *any* `enabled` direct child control is `valid` */\n    readonly isValid: boolean;\n    /** Will return true if *any* direct child control is `disabled` */\n    readonly isDisabled: boolean;\n    /** Will return true if *any* `enabled` direct child control is `readonly` */\n    readonly isReadonly: boolean;\n    /** Will return true if *any* `enabled` direct child control is `required` */\n    readonly isRequired: boolean;\n    /** Will return true if *any* `enabled` direct child control is `pending` */\n    readonly isPending: boolean;\n    /** Will return true if *any* `enabled` direct child control is `touched` */\n    readonly isTouched: boolean;\n    /** Will return true if *any* `enabled` direct child control is `dirty` */\n    readonly isDirty: boolean;\n    /** Will return true if *any* `enabled` direct child control is `submitted` */\n    readonly isSubmitted: boolean;\n  };\n\n  readonly children: {\n    /** Will return true if *all* `enabled` direct child control's are `valid` */\n    readonly areValid: boolean;\n    /** Will return true if *all* direct child control's are `disabled` */\n    readonly areDisabled: boolean;\n    /** Will return true if *all* `enabled` direct child control's are `readonly` */\n    readonly areReadonly: boolean;\n    /** Will return true if *all* `enabled` direct child control's are `required` */\n    readonly areRequired: boolean;\n    /** Will return true if *all* `enabled` direct child control's are `pending` */\n    readonly arePending: boolean;\n    /** Will return true if *all* `enabled` direct child control's are `touched` */\n    readonly areTouched: boolean;\n    /** Will return true if *all* `enabled` direct child control's are `dirty` */\n    readonly areDirty: boolean;\n    /** Will return true if *all* `enabled` direct child control's are `submitted` */\n    readonly areSubmitted: boolean;\n    /** Contains *all* `enabled` child control errors or `null` if there are none */\n    readonly errors: ValidationErrors | null;\n\n    /**\n     * Mark all direct children as disabled. Use the `deep: true`\n     * option to instead mark all direct and indirect children\n     * as disabled.\n     */\n    markDisabled(value: boolean, options?: { deep?: boolean }): void;\n\n    /**\n     * Mark all direct children as touched. Use the `deep: true`\n     * option to instead mark all direct and indirect children\n     * as touched.\n     */\n    markTouched(value: boolean, options?: { deep?: boolean }): void;\n\n    /**\n     * Mark all direct children as dirty. Use the `deep: true`\n     * option to instead mark all direct and indirect children\n     * as dirty.\n     */\n    markDirty(value: boolean, options?: { deep?: boolean }): void;\n\n    /**\n     * Mark all direct children as readonly. Use the `deep: true`\n     * option to instead mark all direct and indirect children\n     * as readonly.\n     */\n    markReadonly(value: boolean, options?: { deep?: boolean }): void;\n\n    /**\n     * Mark all direct children as required. Use the `deep: true`\n     * option to instead mark all direct and indirect children\n     * as required.\n     */\n    markRequired(value: boolean, options?: { deep?: boolean }): void;\n\n    /**\n     * Mark all direct children as submitted. Use the `deep: true`\n     * option to instead mark all direct and indirect children\n     * as submitted.\n     */\n    markSubmitted(value: boolean, options?: { deep?: boolean }): void;\n\n    /**\n     * Mark all direct children as pending. Use the `deep: true`\n     * option to instead mark all direct and indirect children\n     * as pending.\n     */\n    markPending(\n      value: boolean,\n      options?: { source?: ControlId; deep?: boolean }\n    ): void;\n  };\n\n  [AbstractControlContainerInterface]: true;\n\n  /**\n   * Apply a partial update to the values of some children but\n   * not all.\n   */\n  patchValue(value: unknown): void;\n\n  /** sets the `controls` property */\n  setControls(controls: Controls): void;\n\n  /** stores the provided control in `controls[key]` */\n  setControl(key: unknown, control: unknown): void;\n\n  /**\n   * If provided a control value, removes the given control from\n   * `controls`. If provided a control key value, removes the\n   * control associated with the given key from `controls`.\n   */\n  removeControl(keyOrControl: unknown): void;\n}\n","import _isEqual from 'fast-deep-equal/es6';\nimport { getOwner, runWithOwner } from 'solid-js';\nimport type { Merge } from 'type-fest';\n\nexport function isEqual<T>(a: T, b: any): b is T {\n  return _isEqual(a, b);\n}\n\nexport function mergeObj<A, B>(a: A, b: Merge<Partial<A>, B>): Merge<A, B> {\n  return Object.defineProperties(\n    a,\n    Object.getOwnPropertyDescriptors(b)\n  ) as unknown as Merge<A, B>;\n}\n\n/**\n * Helper to bind the owner of the current context to the\n * supplied function.\n *\n * Implementation is very simple:\n * ```ts\n * import { getOwner, runWithOwner } from 'solid-js';\n *\n * export function bindOwner<T>(fn: () => T): () => T {\n *   const owner = getOwner();\n *\n *   if (!owner) {\n *     throw new Error('No solidjs owner in current context');\n *   }\n *\n *   return () => runWithOwner(owner, fn);\n * }\n * ```\n */\nexport function bindOwner<T>(fn: () => T): () => T {\n  const owner = getOwner();\n\n  if (!owner) {\n    throw new Error('No solidjs owner in current context');\n  }\n\n  return () => runWithOwner(owner, fn);\n}\n","import type {\n  ValidatorFn,\n  ValidationErrors,\n  ControlId,\n  AbstractControlInterface,\n} from './abstract-control';\nimport { IAbstractControl } from './abstract-control';\nimport { produce, SetStoreFunction, Store } from 'solid-js/store';\nimport {\n  Accessor,\n  createComputed,\n  createMemo,\n  createSignal,\n  on,\n} from 'solid-js';\nimport { isEqual } from './util';\n\nexport const DEFAULT_SOURCE = 'CONTROL_DEFAULT_SOURCE';\n\nexport interface IAbstractControlBaseOptions<\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> {\n  id?: ControlId;\n  data?: Data;\n  disabled?: boolean;\n  touched?: boolean;\n  dirty?: boolean;\n  readonly?: boolean;\n  required?: boolean;\n  submitted?: boolean;\n  errors?: null | ValidationErrors | ReadonlyMap<ControlId, ValidationErrors>;\n  validators?:\n    | null\n    | ValidatorFn\n    | ValidatorFn[]\n    | ReadonlyMap<ControlId, ValidatorFn>;\n  pending?: boolean | ReadonlySet<ControlId>;\n}\n\nexport function propInitializer(): [\n  propInitializing: <T>(value: T) => T,\n  initComplete: () => void\n] {\n  const [initializationSignal, setInitializationSignal] = createSignal<\n    null | false\n  >(null);\n\n  return [\n    <T>(value: T) => initializationSignal() || value,\n    () => setInitializationSignal(false),\n  ];\n}\n\nexport function composeValidators(\n  validators: undefined | null | ValidatorFn | ValidatorFn[]\n): null | ValidatorFn {\n  if (!validators || (Array.isArray(validators) && validators.length === 0)) {\n    return null;\n  }\n\n  if (Array.isArray(validators)) {\n    return (control) =>\n      validators.reduce((prev: ValidationErrors | null, curr: ValidatorFn) => {\n        const errors = curr(control);\n        return errors ? { ...prev, ...errors } : prev;\n      }, null);\n  }\n\n  return validators;\n}\n\nexport type IAbstractControlBase<\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> = Omit<\n  IAbstractControl<unknown, Data, unknown>,\n  'value' | 'rawValue' | 'setValue' | typeof AbstractControlInterface\n>;\n\nlet controlId = 0;\n\nexport function createAbstractControlBase<\n  RawValue,\n  Data extends Record<ControlId, any> = Record<ControlId, any>,\n  Value = RawValue\n>(\n  store: Accessor<\n    [\n      Store<IAbstractControl<RawValue, Data, Value>>,\n      SetStoreFunction<IAbstractControl<RawValue, Data, Value>>\n    ]\n  >,\n  untilInit: <T>(value: T) => T,\n  initOptions: Pick<IAbstractControlBaseOptions<Data>, 'id' | 'data'> = {}\n): [base: IAbstractControlBase<Data>, initializer: () => void] {\n  let control: Store<IAbstractControl<RawValue, Data, Value>>;\n  let setControl: SetStoreFunction<IAbstractControl<RawValue, Data, Value>>;\n\n  let selfIsPendingMemo: Accessor<IAbstractControl['self']['isPending']>;\n  let selfErrorsMemo: Accessor<ValidationErrors | null>;\n  let statusMemo: Accessor<IAbstractControl['status']>;\n  let validatorMemo: Accessor<IAbstractControl['validator']>;\n\n  const base: IAbstractControlBase<Data> = {\n    id: initOptions.id || Symbol(`AbstractControl-${controlId++}`),\n\n    data: { ...(initOptions.data as Data) },\n\n    self: {\n      get isValid() {\n        // here \"this\" is self\n        return this.errors === null && !this.isPending;\n      },\n      isDisabled: false,\n      isTouched: false,\n      isDirty: false,\n      isReadonly: false,\n      isSubmitted: false,\n      isRequired: false,\n      get isPending() {\n        return selfIsPendingMemo?.() ?? untilInit(false);\n      },\n      get errors() {\n        return selfErrorsMemo?.() ?? untilInit(null);\n      },\n      errorsStore: new Map(),\n      pendingStore: new Set(),\n      validatorStore: new Map(),\n    },\n\n    get isDisabled() {\n      return this.self.isDisabled;\n    },\n\n    get isTouched() {\n      return this.self.isTouched;\n    },\n\n    get isDirty() {\n      return this.self.isDirty;\n    },\n\n    get isReadonly() {\n      return this.self.isReadonly;\n    },\n\n    get isSubmitted() {\n      return this.self.isSubmitted;\n    },\n\n    get isRequired() {\n      return this.self.isRequired;\n    },\n\n    get errors() {\n      return this.self.errors;\n    },\n\n    get isPending() {\n      return this.self.isPending;\n    },\n\n    get isValid() {\n      return this.self.isValid;\n    },\n\n    get status() {\n      return statusMemo?.() ?? untilInit('VALID');\n    },\n\n    get validator() {\n      return validatorMemo?.() ?? untilInit(null);\n    },\n\n    markDisabled(input) {\n      if (isEqual(this.self.isDisabled, input)) return;\n      setControl('self', 'isDisabled', input);\n    },\n\n    markReadonly(input) {\n      if (isEqual(this.self.isReadonly, input)) return;\n      setControl('self', 'isReadonly', input);\n    },\n\n    markRequired(input) {\n      if (isEqual(this.self.isRequired, input)) return;\n      setControl('self', 'isRequired', input);\n    },\n\n    markDirty(input) {\n      if (isEqual(this.self.isDirty, input)) return;\n      setControl('self', 'isDirty', input);\n    },\n\n    markTouched(input) {\n      if (isEqual(this.self.isTouched, input)) return;\n      setControl('self', 'isTouched', input);\n    },\n\n    markSubmitted(input) {\n      if (isEqual(this.self.isSubmitted, input)) return;\n      setControl('self', 'isSubmitted', input);\n    },\n\n    markPending(input, options) {\n      let newPendingStore: Set<ControlId>;\n\n      if (typeof input === 'boolean') {\n        const source = options?.source || DEFAULT_SOURCE;\n\n        if (this.self.pendingStore.has(source) === input) return;\n\n        newPendingStore = new Set(this.self.pendingStore);\n\n        if (input) {\n          newPendingStore.add(source);\n        } else {\n          newPendingStore.delete(source);\n        }\n      } else {\n        if (this.self.pendingStore === input) return;\n\n        newPendingStore = new Set(input);\n      }\n\n      if (isEqual(this.self.pendingStore, newPendingStore)) return;\n\n      // We're using `produce()` here because using the standard solid Store\n      // nested setter has some bugs (i.e.\n      // `setControl('self', 'pendingStore', newPendingStore)`). I think the\n      // bugs are isolated to object values, so, at the moment, I'm only using\n      // produce where the value is an object.\n      setControl(\n        produce((state) => {\n          (state.self.pendingStore as Set<ControlId>) = newPendingStore;\n        })\n      );\n    },\n\n    setErrors(input, options) {\n      const source = options?.source || DEFAULT_SOURCE;\n\n      const existingStore = this.self.errorsStore;\n\n      let newErrorsStore: Map<ControlId, ValidationErrors>;\n\n      if (input instanceof Map) {\n        newErrorsStore = input;\n      } else if (input === null || Object.keys(input).length === 0) {\n        newErrorsStore = new Map(existingStore);\n        newErrorsStore.delete(source);\n      } else {\n        newErrorsStore = new Map(existingStore).set(source, input);\n      }\n\n      if (isEqual(this.self.errorsStore, newErrorsStore)) return;\n\n      // We're using `produce()` here because using the standard solid Store\n      // nested setter has some bugs (i.e.\n      // `setControl('self', 'pendingStore', newPendingStore)`). I think the\n      // bugs are isolated to object values, so, at the moment, I'm only using\n      // produce where the value is an object.\n      setControl(\n        produce((state) => {\n          (state.self.errorsStore as Map<ControlId, ValidationErrors>) =\n            newErrorsStore;\n        })\n      );\n    },\n\n    patchErrors(input, options) {\n      const existingStore = this.self.errorsStore as Map<\n        ControlId,\n        ValidationErrors\n      >;\n\n      if (input instanceof Map) {\n        // We're using `produce()` here because using the standard solid Store\n        // nested setter has some bugs (i.e.\n        // `setControl('self', 'pendingStore', newPendingStore)`). I think the\n        // bugs are isolated to object values, so, at the moment, I'm only using\n        // produce where the value is an object.\n        setControl(\n          produce((state) => {\n            (state.self.errorsStore as Map<ControlId, ValidationErrors>) =\n              new Map([...existingStore, ...input]);\n          })\n        );\n      } else {\n        if (Object.keys(input).length === 0) return;\n\n        const source = options?.source || DEFAULT_SOURCE;\n\n        let newErrors: ValidationErrors = input;\n\n        let existingValue = existingStore.get(source);\n\n        if (existingValue) {\n          existingValue = { ...existingValue };\n\n          for (const [k, err] of Object.entries(newErrors)) {\n            if (err === null) {\n              delete existingValue![k];\n            } else {\n              existingValue![k] = err;\n            }\n          }\n\n          newErrors = existingValue;\n        } else {\n          const entries = Object.entries(newErrors).filter(\n            ([, v]) => v !== null\n          );\n\n          if (entries.length === 0) return;\n\n          newErrors = Object.fromEntries(entries);\n        }\n\n        const newErrorsStore = new Map(existingStore);\n\n        if (Object.keys(newErrors).length === 0) {\n          newErrorsStore.delete(source);\n        } else {\n          newErrorsStore.set(source, newErrors);\n        }\n\n        if (isEqual(this.self.errorsStore, newErrorsStore)) return;\n\n        // We're using `produce()` here because using the standard solid Store\n        // nested setter has some bugs (i.e.\n        // `setControl('self', 'pendingStore', newPendingStore)`). I think the\n        // bugs are isolated to object values, so, at the moment, I'm only using\n        // produce where the value is an object.\n        setControl(\n          produce((state) => {\n            (state.self.errorsStore as Map<ControlId, ValidationErrors>) =\n              newErrorsStore;\n          })\n        );\n      }\n    },\n\n    setValidators(input, options) {\n      const source = options?.source || DEFAULT_SOURCE;\n\n      let newValidatorsStore: Map<ControlId, ValidatorFn>;\n\n      if (input instanceof Map) {\n        newValidatorsStore = new Map(input);\n      } else {\n        newValidatorsStore = new Map(\n          this.self.validatorStore as Map<ControlId, ValidatorFn>\n        );\n\n        const newValidator = composeValidators(\n          input as Exclude<typeof input, ReadonlyMap<any, any>>\n        );\n\n        if (newValidator) {\n          newValidatorsStore.set(source, newValidator);\n        } else {\n          newValidatorsStore.delete(source);\n        }\n      }\n\n      if (isEqual(this.self.validatorStore, newValidatorsStore)) return;\n\n      // We're using `produce()` here because using the standard solid Store\n      // nested setter has some bugs (i.e.\n      // `setControl('self', 'pendingStore', newPendingStore)`). I think the\n      // bugs are isolated to object values, so, at the moment, I'm only using\n      // produce where the value is an object.\n      setControl(\n        produce((state) => {\n          (state.self.validatorStore as Map<ControlId, ValidatorFn<any>>) =\n            newValidatorsStore;\n        })\n      );\n    },\n\n    setData(key, input) {\n      if (isEqual(this.data[key], input)) return;\n      // We're using `produce()` here because using the standard solid Store\n      // nested setter has some bugs (i.e.\n      // `setControl('self', 'pendingStore', newPendingStore)`). I think the\n      // bugs are isolated to object values, so, at the moment, I'm only using\n      // produce where the value is an object.\n      setControl(\n        produce((state) => {\n          state.data[key] = input;\n        })\n      );\n    },\n  };\n\n  const initializer = () => {\n    [control, setControl] = store();\n\n    selfIsPendingMemo = createMemo(() => control.self.pendingStore.size > 0);\n\n    selfErrorsMemo = createMemo(() => {\n      return control.self.errorsStore.size === 0\n        ? null\n        : Array.from(\n            control.self.errorsStore.values()\n          ).reduce<ValidationErrors>(\n            (p, errors) => ({\n              ...p,\n              ...errors,\n            }),\n            {}\n          );\n    });\n\n    statusMemo = createMemo(() => {\n      return control.isDisabled\n        ? 'DISABLED'\n        : control.isPending\n        ? 'PENDING'\n        : control.isValid\n        ? 'VALID'\n        : 'INVALID';\n    });\n\n    validatorMemo = createMemo(() => {\n      if (control.self.validatorStore.size === 0) return null;\n\n      const validators = Array.from(control.self.validatorStore.values());\n\n      return (c) => {\n        const e = validators.reduce<ValidationErrors>((err, v) => {\n          return { ...err, ...v(c) };\n        }, {});\n\n        return Object.keys(e).length === 0 ? null : e;\n      };\n    });\n\n    // Intentionally not using `createRenderEffect()` since it appears to\n    // mess with initializing a control with errors (i.e. it clears the errors\n    // after the control is initialized)\n    createComputed(\n      on(\n        () => control.validator?.(control.rawValue) ?? null,\n        (errors) => {\n          if (control.self.errorsStore.get(DEFAULT_SOURCE) === errors) return;\n\n          const newErrorsStore = new Map(\n            control.self.errorsStore as Map<ControlId, ValidationErrors>\n          );\n\n          if (errors) {\n            newErrorsStore.set(DEFAULT_SOURCE, errors);\n          } else {\n            newErrorsStore.delete(DEFAULT_SOURCE);\n          }\n\n          if (isEqual(control.self.errorsStore, newErrorsStore)) return;\n\n          // We're using `produce()` here because using the standard solid Store\n          // nested setter has some bugs (i.e.\n          // `setControl('self', 'pendingStore', newPendingStore)`). I think the\n          // bugs are isolated to object values, so, at the moment, I'm only using\n          // produce where the value is an object.\n          setControl(\n            produce((state) => {\n              (state.self.errorsStore as Map<ControlId, ValidationErrors>) =\n                newErrorsStore;\n            })\n          );\n        }\n      )\n    );\n  };\n\n  return [base, initializer];\n}\n","import { createStore, produce, SetStoreFunction, Store } from 'solid-js/store';\nimport {\n  IAbstractControl,\n  ControlId,\n  AbstractControlInterface,\n  isAbstractControl,\n} from './abstract-control';\nimport {\n  IAbstractControlBaseOptions,\n  createAbstractControlBase,\n  propInitializer,\n} from './abstract-control-base';\nimport { isEqual, mergeObj } from './util';\n\nexport const FormControlInterface = '@@FormControlInterface_solidjs';\n\nexport interface IFormControlOptions<\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> extends IAbstractControlBaseOptions<Data> {}\n\nexport interface IFormControl<\n  Value = any,\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> extends IAbstractControl<Value, Data, Value> {\n  [FormControlInterface]: true;\n}\n\n/**\n * Returns true if the provided object implements\n * `IFormControl`\n */\nexport function isFormControl(object?: unknown): object is IFormControl {\n  return (\n    isAbstractControl(object) &&\n    (object as any)?.[FormControlInterface] === true\n  );\n}\n\nexport function createFormControl<\n  Value,\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n>(\n  value?: Value,\n  options?: IFormControlOptions<Data>\n): IFormControl<Value, Data>;\nexport function createFormControl<\n  Value,\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n>(\n  initValue?: Value,\n  initOptions: IFormControlOptions<Data> = {}\n): IFormControl<Value, Data> {\n  let control: Store<IFormControl<Value, Data>>;\n  let setControl: SetStoreFunction<IFormControl<Value, Data>>;\n\n  const [untilInit, initComplete] = propInitializer();\n\n  const [base, initializeBase] = createAbstractControlBase<Value, Data, Value>(\n    () => [control, setControl],\n    untilInit,\n    initOptions\n  );\n\n  const storeConfig = mergeObj(base, {\n    [AbstractControlInterface]: true,\n    [FormControlInterface]: true,\n\n    rawValue: initValue as Value,\n\n    get value() {\n      return this.rawValue;\n    },\n\n    setValue(value) {\n      if (isEqual(this.value, value)) return;\n\n      // We're using `produce()` here because using the standard solid Store\n      // nested setter has some bugs (i.e.\n      // `setControl('self', 'pendingStore', newPendingStore)`). I think the\n      // bugs are isolated to object values, so, at the moment, I'm only using\n      // produce where the value could be an object.\n      setControl(\n        produce((state) => {\n          (state.rawValue as Value) = value;\n        })\n      );\n    },\n  } as IFormControl<Value, Data>);\n\n  [control, setControl] = createStore<IFormControl<Value, Data>>(storeConfig);\n\n  initializeBase();\n  initComplete();\n\n  // Intentionally not using `batch()` since it appears to mess with\n  // initializing a control with errors\n  if (initOptions.disabled) control.markDisabled(initOptions.disabled);\n  if (initOptions.touched) control.markTouched(initOptions.touched);\n  if (initOptions.dirty) control.markDirty(initOptions.dirty);\n  if (initOptions.readonly) control.markReadonly(initOptions.readonly);\n  if (initOptions.submitted) control.markSubmitted(initOptions.submitted);\n  if (initOptions.required) control.markRequired(initOptions.required);\n  if (initOptions.pending) control.markPending(initOptions.pending);\n  if (initOptions.validators) control.setValidators(initOptions.validators);\n  if (initOptions.pending) control.markPending(initOptions.pending);\n  // this needs to be last to ensure that the errors aren't overwritten\n  if (initOptions.errors) control.patchErrors(initOptions.errors);\n\n  return control as unknown as IFormControl<Value, Data>;\n}\n","import {\n  AbstractControlInterface,\n  ControlId,\n  isAbstractControl,\n  ValidationErrors,\n} from './abstract-control';\n\nimport { IAbstractControl } from './abstract-control';\n\nimport {\n  AbstractControlContainerInterface,\n  ControlsKey,\n  ControlsRawValue,\n  ControlsValue,\n  GenericControlsObject,\n  isAbstractControlContainer,\n} from './abstract-control-container';\n\nimport { IAbstractControlContainer } from './abstract-control-container';\n\nimport {\n  createAbstractControlBase,\n  IAbstractControlBaseOptions,\n} from './abstract-control-base';\n\nimport { produce, SetStoreFunction, Store } from 'solid-js/store';\nimport { Accessor, batch, createMemo } from 'solid-js';\nimport { isEqual, mergeObj } from './util';\nimport type { PartialDeep } from 'type-fest';\n\nexport interface IAbstractControlContainerBaseArgs<\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> extends IAbstractControlBaseOptions<Data> {}\n\nexport interface IAbstractControlContainerBase<\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> extends Omit<\n    IAbstractControlContainer<any, Data>,\n    | 'value'\n    | 'rawValue'\n    | 'controls'\n    | 'setControl'\n    | typeof AbstractControlInterface\n    | typeof AbstractControlContainerInterface\n  > {}\n\nexport function createAbstractControlContainerBase<\n  Controls extends GenericControlsObject = any,\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n>(\n  store: Accessor<\n    [\n      Store<IAbstractControlContainer<Controls, Data>>,\n      SetStoreFunction<IAbstractControlContainer<Controls, Data>>\n    ]\n  >,\n  untilInit: <T>(value: T) => T,\n  initOptions: IAbstractControlContainerBaseArgs<Data> = {}\n): [base: IAbstractControlContainerBase<Data>, initializer: () => void] {\n  let control: Store<IAbstractControlContainer<Controls, Data>>;\n  let setControl: SetStoreFunction<IAbstractControlContainer<Controls, Data>>;\n\n  const [base, initializeAbstractControl] = createAbstractControlBase<\n    ControlsRawValue<Controls>,\n    Data,\n    ControlsValue<Controls>\n  >(() => [control, setControl], untilInit, initOptions);\n\n  let sizeMemo: Accessor<number>;\n\n  let childIsValidMemo: Accessor<boolean>;\n  let childIsDisabledMemo: Accessor<boolean>;\n  let childIsReadonlyMemo: Accessor<boolean>;\n  let childIsRequiredMemo: Accessor<boolean>;\n  let childIsPendingMemo: Accessor<boolean>;\n  let childIsTouchedMemo: Accessor<boolean>;\n  let childIsDirtyMemo: Accessor<boolean>;\n  let childIsSubmittedMemo: Accessor<boolean>;\n\n  let childrenAreValidMemo: Accessor<boolean>;\n  let childrenAreDisabledMemo: Accessor<boolean>;\n  let childrenAreReadonlyMemo: Accessor<boolean>;\n  let childrenAreRequiredMemo: Accessor<boolean>;\n  let childrenArePendingMemo: Accessor<boolean>;\n  let childrenAreTouchedMemo: Accessor<boolean>;\n  let childrenAreDirtyMemo: Accessor<boolean>;\n  let childrenAreSubmittedMemo: Accessor<boolean>;\n\n  let errorsMemo: Accessor<ValidationErrors | null>;\n  let childrenErrorsMemo: Accessor<ValidationErrors | null>;\n\n  const containerBase = mergeObj(base, {\n    get size() {\n      return sizeMemo?.() ?? untilInit(0);\n    },\n\n    get isDisabled() {\n      return this.self.isDisabled || this.children.areDisabled;\n    },\n\n    get isTouched() {\n      return this.self.isTouched || this.child.isTouched;\n    },\n\n    get isDirty() {\n      return this.self.isDirty || this.child.isDirty;\n    },\n\n    get isReadonly() {\n      return this.self.isReadonly || this.children.areReadonly;\n    },\n\n    get isSubmitted() {\n      return this.self.isSubmitted || this.children.areSubmitted;\n    },\n\n    get isRequired() {\n      return this.self.isRequired || this.child.isRequired;\n    },\n\n    get isPending() {\n      return this.self.isPending || this.child.isPending;\n    },\n\n    get errors() {\n      return errorsMemo?.() ?? untilInit(null);\n    },\n\n    get isValid() {\n      return this.self.isValid && this.children.areValid;\n    },\n\n    child: {\n      /** Will return true if *any* `enabled` direct child control is `valid` */\n      get isValid() {\n        return childIsValidMemo?.() ?? untilInit(true);\n      },\n      /** Will return true if *any* direct child control is `disabled` */\n      get isDisabled() {\n        return childIsDisabledMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *any* `enabled` direct child control is `readonly` */\n      get isReadonly() {\n        return childIsReadonlyMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *any* `enabled` direct child control is `required` */\n      get isRequired() {\n        return childIsRequiredMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *any* `enabled` direct child control is `pending` */\n      get isPending() {\n        return childIsPendingMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *any* `enabled` direct child control is `touched` */\n      get isTouched() {\n        return childIsTouchedMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *any* `enabled` direct child control is `dirty` */\n      get isDirty() {\n        return childIsDirtyMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *any* `enabled` direct child control is `submitted` */\n      get isSubmitted() {\n        return childIsSubmittedMemo?.() ?? untilInit(false);\n      },\n    },\n\n    children: {\n      /** Will return true if *all* `enabled` direct child control's are `valid` */\n      get areValid() {\n        return childrenAreValidMemo?.() ?? untilInit(true);\n      },\n      /** Will return true if *all* direct child control's are `disabled` */\n      get areDisabled() {\n        return childrenAreDisabledMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *all* `enabled` direct child control's are `readonly` */\n      get areReadonly() {\n        return childrenAreReadonlyMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *all* `enabled` direct child control's are `required` */\n      get areRequired() {\n        return childrenAreRequiredMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *all* `enabled` direct child control's are `pending` */\n      get arePending() {\n        return childrenArePendingMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *all* `enabled` direct child control's are `touched` */\n      get areTouched() {\n        return childrenAreTouchedMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *all* `enabled` direct child control's are `dirty` */\n      get areDirty() {\n        return childrenAreDirtyMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *all* `enabled` direct child control's are `submitted` */\n      get areSubmitted() {\n        return childrenAreSubmittedMemo?.() ?? untilInit(false);\n      },\n      /** Contains *all* `enabled` child control errors or `null` if there are none */\n      get errors() {\n        return childrenErrorsMemo?.() ?? untilInit(null);\n      },\n\n      markDirty(value, options) {\n        batch(() => {\n          Object.values(control.controls).forEach((c) => {\n            (c as IAbstractControl).markDirty(value);\n\n            if (!options?.deep || !isAbstractControlContainer(c)) {\n              return;\n            }\n\n            c.children.markDirty(value, options);\n          });\n        });\n      },\n\n      markDisabled(value, options) {\n        batch(() => {\n          Object.values(control.controls).forEach((c) => {\n            (c as IAbstractControl).markDisabled(value);\n\n            if (!options?.deep || !isAbstractControlContainer(c)) {\n              return;\n            }\n\n            c.children.markDisabled(value, options);\n          });\n        });\n      },\n\n      markPending(value, options) {\n        batch(() => {\n          Object.values(control.controls).forEach((c) => {\n            (c as IAbstractControl).markPending(value, options);\n\n            if (!options?.deep || !isAbstractControlContainer(c)) {\n              return;\n            }\n\n            c.children.markPending(value, options);\n          });\n        });\n      },\n\n      markReadonly(value, options) {\n        batch(() => {\n          Object.values(control.controls).forEach((c) => {\n            (c as IAbstractControl).markReadonly(value);\n\n            if (!options?.deep || !isAbstractControlContainer(c)) {\n              return;\n            }\n\n            c.children.markReadonly(value, options);\n          });\n        });\n      },\n\n      markRequired(value, options) {\n        batch(() => {\n          Object.values(control.controls).forEach((c) => {\n            (c as IAbstractControl).markRequired(value);\n\n            if (!options?.deep || !isAbstractControlContainer(c)) {\n              return;\n            }\n\n            c.children.markRequired(value, options);\n          });\n        });\n      },\n\n      markSubmitted(value, options) {\n        batch(() => {\n          Object.values(control.controls).forEach((c) => {\n            (c as IAbstractControl).markSubmitted(value);\n\n            if (!options?.deep || !isAbstractControlContainer(c)) {\n              return;\n            }\n\n            c.children.markSubmitted(value, options);\n          });\n        });\n      },\n\n      markTouched(value, options) {\n        batch(() => {\n          Object.values(control.controls).forEach((c) => {\n            (c as IAbstractControl).markTouched(value);\n\n            if (!options?.deep || !isAbstractControlContainer(c)) {\n              return;\n            }\n\n            c.children.markTouched(value, options);\n          });\n        });\n      },\n    },\n\n    setControls(controls: Controls) {\n      if (isEqual(control.controls, controls)) return;\n\n      // We're using `produce()` here because using the standard solid Store\n      // nested setter has some bugs (i.e.\n      // `setControl('self', 'pendingStore', newPendingStore)`). I think the\n      // bugs are isolated to object values, so, at the moment, I'm only using\n      // produce where the value is an object.\n      setControl(\n        produce((state) => {\n          (state.controls as Controls) = controls;\n        })\n      );\n    },\n\n    /**\n     * The provided control is removed from this FormGroup\n     * if it is a child of this FormGroup. Or the control\n     * associated with the provided key is removed.\n     */\n    removeControl(\n      keyOrControl: ControlsKey<Controls> | Controls[ControlsKey<Controls>]\n    ) {\n      if (!isAbstractControl(keyOrControl)) {\n        control.setControl(keyOrControl as ControlsKey<Controls>, null);\n        return;\n      }\n\n      const childControl = keyOrControl;\n\n      for (const [key, c] of Object.entries(control.controls!)) {\n        if (c !== childControl) continue;\n\n        control.setControl(key as ControlsKey<Controls>, null);\n        return;\n      }\n    },\n\n    setValue(value: ControlsRawValue<Controls>) {\n      const valueEntries = Object.entries(value);\n\n      if (valueEntries.length !== control.size!) {\n        throw new Error(\n          `setValue error: you must provide a value for each control.`\n        );\n      }\n\n      batch(() => {\n        for (const [key, val] of valueEntries) {\n          const c = control.controls[\n            key as ControlsKey<Controls>\n          ] as unknown as IAbstractControl | undefined;\n\n          if (!c) {\n            throw new Error(`Invalid setValue value key \"${key}\".`);\n          }\n\n          c.setValue(val);\n        }\n      });\n    },\n\n    patchValue(value: PartialDeep<ControlsRawValue<Controls>>) {\n      batch(() => {\n        for (const [key, entryValue] of Object.entries(value)) {\n          const c = control.controls[\n            key as ControlsKey<Controls>\n          ] as unknown as IAbstractControl | undefined;\n\n          if (!c) {\n            throw new Error(`Invalid patchValue value key \"${key}\".`);\n          }\n\n          if (isAbstractControlContainer(c)) {\n            c.patchValue(entryValue);\n          } else {\n            c.setValue(entryValue);\n          }\n        }\n      });\n    },\n  } as IAbstractControlContainerBase<Data>);\n\n  const initializer = () => {\n    [control, setControl] = store();\n\n    initializeAbstractControl();\n\n    const allControlsMemo = createMemo(() => Object.values(control.controls));\n\n    const nonDisabledControlsMemo = createMemo(() =>\n      allControlsMemo().filter((c) => !c.isDisabled)\n    );\n\n    sizeMemo = createMemo(() => allControlsMemo().length);\n\n    childIsValidMemo = createMemo(() =>\n      nonDisabledControlsMemo().some((c) => c.isValid)\n    );\n\n    childIsDisabledMemo = createMemo(() =>\n      allControlsMemo().some((c) => c.isDisabled)\n    );\n\n    childIsReadonlyMemo = createMemo(() =>\n      nonDisabledControlsMemo().some((c) => c.isReadonly)\n    );\n\n    childIsRequiredMemo = createMemo(() =>\n      nonDisabledControlsMemo().some((c) => c.isRequired)\n    );\n\n    childIsPendingMemo = createMemo(() =>\n      nonDisabledControlsMemo().some((c) => c.isPending)\n    );\n\n    childIsTouchedMemo = createMemo(() =>\n      nonDisabledControlsMemo().some((c) => c.isTouched)\n    );\n\n    childIsDirtyMemo = createMemo(() =>\n      nonDisabledControlsMemo().some((c) => c.isDirty)\n    );\n\n    childIsSubmittedMemo = createMemo(() =>\n      nonDisabledControlsMemo().some((c) => c.isSubmitted)\n    );\n\n    childrenAreValidMemo = createMemo(() =>\n      nonDisabledControlsMemo().every((c) => c.isValid)\n    );\n\n    childrenAreDisabledMemo = createMemo(() => {\n      const controls = allControlsMemo();\n\n      if (controls.length === 0) return false;\n\n      return controls.every((c) => c.isDisabled);\n    });\n\n    childrenAreReadonlyMemo = createMemo(() => {\n      const controls = nonDisabledControlsMemo();\n\n      if (controls.length === 0) return false;\n\n      return controls.every((c) => c.isReadonly);\n    });\n\n    childrenAreRequiredMemo = createMemo(() => {\n      const controls = nonDisabledControlsMemo();\n\n      if (controls.length === 0) return false;\n\n      return controls.every((c) => c.isRequired);\n    });\n\n    childrenArePendingMemo = createMemo(() => {\n      const controls = nonDisabledControlsMemo();\n\n      if (controls.length === 0) return false;\n\n      return controls.every((c) => c.isPending);\n    });\n\n    childrenAreTouchedMemo = createMemo(() => {\n      const controls = nonDisabledControlsMemo();\n\n      if (controls.length === 0) return false;\n\n      return controls.every((c) => c.isTouched);\n    });\n\n    childrenAreDirtyMemo = createMemo(() => {\n      const controls = nonDisabledControlsMemo();\n\n      if (controls.length === 0) return false;\n\n      return controls.every((c) => c.isDirty);\n    });\n\n    childrenAreSubmittedMemo = createMemo(() => {\n      const controls = nonDisabledControlsMemo();\n\n      if (controls.length === 0) return false;\n\n      return controls.every((c) => c.isSubmitted);\n    });\n\n    errorsMemo = createMemo(() => {\n      if (!control.self.errors && !control.children.errors) return null;\n\n      return {\n        ...control.children.errors,\n        ...control.self.errors,\n      };\n    });\n\n    childrenErrorsMemo = createMemo(() => {\n      const controls = nonDisabledControlsMemo();\n\n      return controls.reduce((prev, curr) => {\n        return prev === null && curr.errors === null\n          ? null\n          : { ...prev, ...curr.errors };\n      }, null as ValidationErrors | null);\n    });\n  };\n\n  return [containerBase, initializer];\n}\n","import {\n  AbstractControlInterface,\n  ControlId,\n  IAbstractControl,\n} from './abstract-control';\nimport { createAbstractControlContainerBase } from './abstract-control-container-base';\nimport {\n  ControlsValue,\n  ControlsRawValue,\n  ControlsKey,\n  IAbstractControlContainer,\n  AbstractControlContainerInterface,\n  isAbstractControlContainer,\n} from './abstract-control-container';\nimport {\n  IAbstractControlBaseOptions,\n  propInitializer,\n} from './abstract-control-base';\nimport { createStore, produce, SetStoreFunction, Store } from 'solid-js/store';\nimport { Accessor, createMemo } from 'solid-js';\nimport { isEqual, mergeObj } from './util';\nimport type { PartialDeep } from 'type-fest';\n\nexport const FormGroupInterface = '@@FormGroupInterface_solidjs';\n\nexport interface IFormGroupOptions<\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> extends IAbstractControlBaseOptions<Data> {}\n\nexport interface IFormGroup<\n  Controls extends { [key: string]: IAbstractControl } = {\n    [key: string]: IAbstractControl;\n  },\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> extends IAbstractControlContainer<Controls, Data> {\n  [FormGroupInterface]: true;\n  setControls(controls: Controls): void;\n  removeControl(\n    keyOrControl: ControlsKey<Controls> | Controls[ControlsKey<Controls>]\n  ): void;\n  patchValue(value: PartialDeep<ControlsRawValue<Controls>>): void;\n}\n\n/**\n * Returns true if the provided object implements\n * `IFormGroup`\n */\nexport function isFormGroup(object?: unknown): object is IFormGroup {\n  return (\n    isAbstractControlContainer(object) &&\n    (object as any)?.[FormGroupInterface] === true\n  );\n}\n\nexport function createFormGroup<\n  Controls extends { [key: string]: IAbstractControl } = {\n    [key: string]: IAbstractControl;\n  },\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n>(\n  controls?: Controls,\n  options?: IFormGroupOptions<Data>\n): IFormGroup<Controls, Data>;\nexport function createFormGroup<\n  Controls extends { [key: string]: IAbstractControl } = {\n    [key: string]: IAbstractControl;\n  },\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n>(\n  initControls = {} as Controls,\n  initOptions: IFormGroupOptions<Data> = {}\n): IFormGroup<Controls, Data> {\n  let control: Store<IFormGroup<Controls, Data>>;\n  let setControl: SetStoreFunction<IFormGroup<Controls, Data>>;\n\n  const [untilInit, initComplete] = propInitializer();\n\n  const [base, initializeBase] = createAbstractControlContainerBase(\n    () => [control, setControl],\n    untilInit,\n    initOptions\n  );\n\n  let rawValueMemo: Accessor<ControlsRawValue<Controls>>;\n  let valueMemo: Accessor<ControlsValue<Controls>>;\n\n  const storeConfig = mergeObj(base, {\n    [AbstractControlInterface]: true,\n    [AbstractControlContainerInterface]: true,\n    [FormGroupInterface]: true,\n\n    controls: initControls,\n\n    get rawValue() {\n      return rawValueMemo?.() ?? untilInit({});\n    },\n\n    get value() {\n      return valueMemo?.() ?? untilInit({});\n    },\n\n    setControl<N extends ControlsKey<Controls>>(\n      key: N,\n      newControl: Controls[N] | null\n    ) {\n      if (\n        newControl === null\n          ? !control.controls[key]\n          : isEqual(control.controls[key], newControl)\n      ) {\n        return;\n      }\n\n      setControl(\n        produce((state) => {\n          if (newControl === null) {\n            delete state.controls[key];\n          } else {\n            state.controls[key] = newControl;\n          }\n        })\n      );\n    },\n  } as IFormGroup<Controls, Data>);\n\n  [control, setControl] = createStore(storeConfig);\n\n  initializeBase();\n\n  const allControlEntriesMemo = createMemo(() =>\n    Object.entries(control.controls)\n  );\n\n  const enabledControlEntriesMemo = createMemo(() =>\n    allControlEntriesMemo().filter(([, c]) => !c.isDisabled)\n  );\n\n  rawValueMemo = createMemo(\n    () =>\n      Object.fromEntries(\n        allControlEntriesMemo().map(([k, c]) => [k, c.rawValue])\n      ) as ControlsRawValue<Controls>\n  );\n\n  valueMemo = createMemo(\n    () =>\n      Object.fromEntries(\n        enabledControlEntriesMemo().map(([k, c]) => [k, c.value])\n      ) as ControlsValue<Controls>\n  );\n\n  initComplete();\n\n  // Intentionally not using `batch()` since it appears to mess with\n  // initializing a control with errors\n  if (initOptions.disabled) control.markDisabled(initOptions.disabled);\n  if (initOptions.touched) control.markTouched(initOptions.touched);\n  if (initOptions.dirty) control.markDirty(initOptions.dirty);\n  if (initOptions.readonly) control.markReadonly(initOptions.readonly);\n  if (initOptions.submitted) control.markSubmitted(initOptions.submitted);\n  if (initOptions.required) control.markRequired(initOptions.required);\n  if (initOptions.pending) control.markPending(initOptions.pending);\n  if (initOptions.validators) control.setValidators(initOptions.validators);\n  if (initOptions.pending) control.markPending(initOptions.pending);\n  // this needs to be last to ensure that the errors aren't overwritten\n  if (initOptions.errors) control.patchErrors(initOptions.errors);\n\n  return control as unknown as IFormGroup<Controls, Data>;\n}\n","import {\n  AbstractControlInterface,\n  ControlId,\n  IAbstractControl,\n} from './abstract-control';\nimport { createAbstractControlContainerBase } from './abstract-control-container-base';\nimport {\n  ControlsValue,\n  ControlsRawValue,\n  ControlsKey,\n  IAbstractControlContainer,\n  AbstractControlContainerInterface,\n  isAbstractControlContainer,\n} from './abstract-control-container';\nimport {\n  IAbstractControlBaseOptions,\n  propInitializer,\n} from './abstract-control-base';\nimport { createStore, produce, SetStoreFunction, Store } from 'solid-js/store';\nimport { Accessor, batch, createMemo } from 'solid-js';\nimport { isEqual, mergeObj } from './util';\nimport type { PartialDeep } from 'type-fest';\n\nexport const FormArrayInterface = '@@FormArrayInterface_solidjs';\n\nexport interface IFormArrayOptions<\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> extends IAbstractControlBaseOptions<Data> {}\n\nexport interface IFormArray<\n  Controls extends ReadonlyArray<IAbstractControl> = ReadonlyArray<IAbstractControl>,\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> extends IAbstractControlContainer<Controls, Data> {\n  [FormArrayInterface]: true;\n  push(control: Controls[number]): void;\n  setControls(controls: Controls): void;\n  removeControl(\n    keyOrControl: ControlsKey<Controls> | Controls[ControlsKey<Controls>]\n  ): void;\n  patchValue(value: PartialDeep<ControlsRawValue<Controls>>): void;\n}\n\n/**\n * Returns true if the provided object implements\n * `IFormArray`\n */\nexport function isFormArray(object?: unknown): object is IFormArray {\n  return (\n    isAbstractControlContainer(object) &&\n    (object as any)?.[FormArrayInterface] === true\n  );\n}\n\nexport function createFormArray<\n  Controls extends ReadonlyArray<IAbstractControl> = ReadonlyArray<IAbstractControl>,\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n>(\n  controls?: Controls,\n  options?: IFormArrayOptions<Data>\n): IFormArray<Controls, Data>;\nexport function createFormArray<\n  Controls extends ReadonlyArray<IAbstractControl> = ReadonlyArray<IAbstractControl>,\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n>(\n  initControls = [] as unknown as Controls,\n  initOptions: IFormArrayOptions<Data> = {}\n): IFormArray<Controls, Data> {\n  let control: Store<IFormArray<Controls, Data>>;\n  let setControl: SetStoreFunction<IFormArray<Controls, Data>>;\n\n  const [untilInit, initComplete] = propInitializer();\n\n  const [base, initializeBase] = createAbstractControlContainerBase(\n    () => [control, setControl],\n    untilInit,\n    initOptions\n  );\n\n  let rawValueMemo: Accessor<ControlsRawValue<Controls>>;\n  let valueMemo: Accessor<ControlsValue<Controls>>;\n\n  const storeConfig = mergeObj(base, {\n    [AbstractControlInterface]: true,\n    [AbstractControlContainerInterface]: true,\n    [FormArrayInterface]: true,\n\n    controls: initControls,\n\n    get rawValue() {\n      return rawValueMemo?.() ?? untilInit({});\n    },\n\n    get value() {\n      return valueMemo?.() ?? untilInit({});\n    },\n\n    setControl<N extends ControlsKey<Controls>>(\n      key: N,\n      newControl: Controls[N] | null\n    ) {\n      if (\n        newControl === null\n          ? !control.controls[key]\n          : isEqual(control.controls[key], newControl)\n      ) {\n        return;\n      }\n\n      setControl(\n        produce((state) => {\n          if (newControl === null) {\n            (\n              state.controls as unknown as Array<\n                typeof state['controls'][number]\n              >\n            ).splice(key, 1);\n          } else {\n            state.controls[key] = newControl;\n          }\n        })\n      );\n    },\n\n    push(control: Controls[number]) {\n      this.setControl(this.controls.length, control);\n    },\n  } as IFormArray<Controls, Data>);\n\n  [control, setControl] = createStore(storeConfig);\n\n  initializeBase();\n\n  const enabledControlsMemo = createMemo(() =>\n    control.controls.filter((c) => !c.isDisabled)\n  );\n\n  rawValueMemo = createMemo(\n    () =>\n      (control as IFormArray<Controls, Data>).controls.map(\n        (c) => c.rawValue\n      ) as unknown as ControlsRawValue<Controls>\n  );\n\n  valueMemo = createMemo(\n    () =>\n      enabledControlsMemo().map(\n        (c) => c.value\n      ) as unknown as ControlsValue<Controls>\n  );\n\n  initComplete();\n\n  // Intentionally not using `batch()` since it appears to mess with\n  // initializing a control with errors\n  if (initOptions.disabled) control.markDisabled(initOptions.disabled);\n  if (initOptions.touched) control.markTouched(initOptions.touched);\n  if (initOptions.dirty) control.markDirty(initOptions.dirty);\n  if (initOptions.readonly) control.markReadonly(initOptions.readonly);\n  if (initOptions.submitted) control.markSubmitted(initOptions.submitted);\n  if (initOptions.required) control.markRequired(initOptions.required);\n  if (initOptions.pending) control.markPending(initOptions.pending);\n  if (initOptions.validators) control.setValidators(initOptions.validators);\n  if (initOptions.pending) control.markPending(initOptions.pending);\n  // this needs to be last to ensure that the errors aren't overwritten\n  if (initOptions.errors) control.patchErrors(initOptions.errors);\n\n  return control as unknown as IFormArray<Controls, Data>;\n}\n"],"names":["AbstractControlInterface","isAbstractControl","object","AbstractControlContainerInterface","isAbstractControlContainer","isEqual","a","b","_isEqual","mergeObj","Object","defineProperties","getOwnPropertyDescriptors","bindOwner","fn","owner","getOwner","Error","runWithOwner","DEFAULT_SOURCE","propInitializer","createSignal","initializationSignal","setInitializationSignal","value","composeValidators","validators","Array","isArray","length","control","reduce","prev","curr","errors","controlId","createAbstractControlBase","store","untilInit","initOptions","setControl","selfIsPendingMemo","selfErrorsMemo","statusMemo","validatorMemo","base","id","Symbol","data","self","isValid","isPending","isDisabled","isTouched","isDirty","isReadonly","isSubmitted","isRequired","errorsStore","Map","pendingStore","Set","validatorStore","status","validator","markDisabled","input","markReadonly","markRequired","markDirty","markTouched","markSubmitted","markPending","options","newPendingStore","source","has","add","produce","state","setErrors","existingStore","newErrorsStore","keys","set","patchErrors","newErrors","existingValue","get","_objectSpread","entries","k","err","filter","v","fromEntries","setValidators","newValidatorsStore","newValidator","setData","key","initializer","createMemo","size","from","values","p","c","e","createComputed","on","rawValue","FormControlInterface","isFormControl","createFormControl","initValue","initComplete","initializeBase","storeConfig","createStore","disabled","touched","dirty","readonly","submitted","required","pending","createAbstractControlContainerBase","initializeAbstractControl","sizeMemo","childIsValidMemo","childIsDisabledMemo","childIsReadonlyMemo","childIsRequiredMemo","childIsPendingMemo","childIsTouchedMemo","childIsDirtyMemo","childIsSubmittedMemo","childrenAreValidMemo","childrenAreDisabledMemo","childrenAreReadonlyMemo","childrenAreRequiredMemo","childrenArePendingMemo","childrenAreTouchedMemo","childrenAreDirtyMemo","childrenAreSubmittedMemo","errorsMemo","childrenErrorsMemo","containerBase","children","areDisabled","child","areReadonly","areSubmitted","areValid","areRequired","arePending","areTouched","areDirty","batch","controls","forEach","deep","setControls","removeControl","keyOrControl","childControl","setValue","valueEntries","val","patchValue","entryValue","allControlsMemo","nonDisabledControlsMemo","some","every","FormGroupInterface","isFormGroup","createFormGroup","initControls","rawValueMemo","valueMemo","newControl","allControlEntriesMemo","enabledControlEntriesMemo","map","FormArrayInterface","isFormArray","createFormArray","splice","enabledControlsMemo"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"index.common.js","sources":["../../src/abstract-control.ts","../../src/abstract-control-container.ts","../../src/util.ts","../../src/abstract-control-base.ts","../../src/form-control.ts","../../src/abstract-control-container-base.ts","../../src/form-group.ts","../../src/form-array.ts"],"sourcesContent":["// *****************************\n// Misc Types\n// *****************************\n\nexport type ControlId = string | symbol;\n\nexport type ValidatorFn<T = any> = (rawValue: T) => ValidationErrors | null;\n\nexport interface ValidationErrors {\n  [key: string]: any;\n}\n\n// *****************************\n// AbstractControl interface\n// *****************************\n\nexport const AbstractControlInterface = '@@AbstractControlInterface_solidjs';\n\n/** Returns true if the provided object implements `IAbstractControl` */\nexport function isAbstractControl(\n  object?: unknown\n): object is IAbstractControl {\n  return (\n    typeof object === 'object' &&\n    (object as any)?.[AbstractControlInterface] === true\n  );\n}\n\nexport interface IAbstractControl<\n  RawValue = any,\n  Data extends Record<ControlId, any> = Record<ControlId, any>,\n  Value = RawValue\n> {\n  /**\n   * The ID is used to determine where StateChanges originated,\n   * and to ensure that a given AbstractControl only processes\n   * values one time.\n   */\n  readonly id: ControlId;\n\n  /**\n   * The data property can store arbitrary custom data. Use the\n   * `setData` method on `IAbstractControl` to update it.\n   *\n   * The `data` property is, itself, an object. You can set individual\n   * keys on the data property with `setData` but you cannot reset\n   * or clear the whole object. This is intentional. A library\n   * maintainer can store private data within the `data` property\n   * using a symbol without fear of the user accidently erasing it.\n   */\n  readonly data: Data;\n\n  /**\n   * The value of the IAbstractControl.\n   *\n   * In an IAbstractControlContainer,\n   * `value` and `rawValue` can be different, but in a standard\n   * `IAbstractControl` `value` is just an alias for `rawValue`.\n   * See the IAbstractControlContainer interface for possible differences\n   * between `value` and `rawValue`.\n   */\n  readonly value: Value;\n\n  /**\n   * The value of the IAbstractControl.\n   *\n   * In an IAbstractControlContainer,\n   * `value` and `rawValue` can be different, but in a standard\n   * `IAbstractControl` `value` is just an alias for `rawValue` and\n   * rawValue just contains the control's value.\n   * See the IAbstractControlContainer interface for possible differences\n   * between `value` and `rawValue`.\n   */\n  readonly rawValue: RawValue;\n\n  /**\n   * `true` if this control is disabled, false otherwise.\n   * This is an alias for `self.isDisabled`.\n   */\n  readonly isDisabled: boolean;\n\n  /**\n   * `true` if this control is touched, false otherwise.\n   * This is an alias for `self.isTouched`.\n   */\n  readonly isTouched: boolean;\n\n  /**\n   * `true` if this control is dirty, false otherwise.\n   * This is an alias for `self.isDirty`.\n   */\n  readonly isDirty: boolean;\n  /**\n   * `true` if this control is readonly, false otherwise.\n   * This is an alias for `self.isReadonly`.\n   */\n  readonly isReadonly: boolean;\n  /**\n   * `true` if this control is submitted, false otherwise.\n   * This is an alias for `self.isSubmitted`.\n   */\n  readonly isSubmitted: boolean;\n  /**\n   * `true` if this control is required, false otherwise.\n   * This is an alias for `self.isRequired`.\n   *\n   * Note that this property doesn't\n   * have any predefined meaning for IAbstractControls and it doesn't affect\n   * validation in any way. It is up to you to decide what meaning, if any,\n   * to give to this property and how to use it. For example, if you\n   * validated the control inside a `createEffect()`, you could choose to alter the\n   * validation based on whether the control was marked as `required` or\n   * not.\n   */\n  readonly isRequired: boolean;\n\n  /**\n   * Contains a `ValidationErrors` object if this control\n   * has any errors. Otherwise contains `null`.\n   *\n   * An alias for `self.errors`.\n   */\n  readonly errors: ValidationErrors | null;\n\n  /**\n   * A validator function that is run on rawValue changes and which\n   * generates errors associated with the source \"CONTROL_DEFAULT_SOURCE\".\n   */\n  readonly validator: ValidatorFn | null;\n\n  /**\n   * `true` if this control is pending, false otherwise.\n   * This is an alias for `self.isPending`.\n   */\n  readonly isPending: boolean;\n\n  /**\n   * Valid if `errors === null && !isPending`\n   *\n   * This is an alias for `self.valid`.\n   */\n  readonly isValid: boolean;\n\n  /**\n   * The `self` object on an abstract control contains\n   * properties reflecting the control's personal state. On an\n   * IAbstractControlContainer, the personal state can differ\n   * from the control's state. For example, an\n   * IAbstractControlContainer will register as disabled if\n   * the control itself has been marked as disabled OR if\n   * all of it's child controls are disabled.\n   *\n   * Marking the control container\n   * itself as disabled doesn't mark the container's children as\n   * disabled. On a standard IAbstractControl though,\n   * the \"self\" properties are the same as regular properties.\n   * I.e. `self.isInvalid` is the same as `isInvalid` on a\n   * standard IAbstractControl (actually, `isInvalid` is\n   * an alias for `self.isInvalid` on a standard control).\n   */\n  readonly self: {\n    /** `this.self.errors === null && !this.self.isPending` */\n    readonly isValid: boolean;\n\n    /** `true` if this control is disabled, false otherwise. */\n    readonly isDisabled: boolean;\n\n    /** `true` if this control is touched, false otherwise. */\n    readonly isTouched: boolean;\n\n    /**\n     * `true` if this control is dirty, false otherwise.\n     *\n     * Dirty can be thought of as, \"Has the value changed?\"\n     * Though the isDirty property must be manually set by\n     * the user (using `markDirty()`) and is not automatically\n     * updated.\n     */\n    readonly isDirty: boolean;\n    /**\n     * `true` if this control is readonly, false otherwise.\n     *\n     * This property does not have any predefined meeting for\n     * an IAbstractControl. You can decide if you want to give\n     * it meaning by, for example, using this value to set\n     * an input's readonly status (e.g.\n     * `<input readonly={control.isReadonly} />`)\n     */\n    readonly isReadonly: boolean;\n\n    /** `true` if this control is submitted, false otherwise. */\n    readonly isSubmitted: boolean;\n\n    /**\n     * `true` if this control is required, false otherwise.\n     *\n     * Note that this property doesn't\n     * have any predefined meaning for IAbstractControls and it doesn't affect\n     * validation in any way. It is up to you to decide what meaning, if any,\n     * to give to this property and how to use it. For example, if you\n     * validated the control inside a `createEffect()` you could alter the\n     * validation based on whether the control was marked as `required` or\n     * not.\n     */\n    readonly isRequired: boolean;\n\n    /** `true` if this control is pending, false otherwise. */\n    readonly isPending: boolean;\n\n    /**\n     * Contains a `ValidationErrors` object if this control\n     * has any errors. Otherwise contains `null`.\n     */\n    readonly errors: ValidationErrors | null;\n\n    /**\n     * *More advanced-ish*\n     *\n     * Contains a map of ControlId values and ValidationErrors.\n     * The errorsStore allows partitioning errors so that\n     * they can be associated with different sources and so\n     * that one source does not overwrite another source.\n     *\n     * The `self.errors` property gets its errors from the errorsStore.\n     */\n    readonly errorsStore: ReadonlyMap<ControlId, ValidationErrors>;\n\n    /**\n     * More advanced-ish*\n     *\n     * A set of ControlIds. `self.isPending` is true so long\n     * as `pendingStore.size > 0`. Because this is a set, you\n     * can track multiple pending \"things\" at once. This\n     * control will register as pending until all of the \"things\"\n     * have resolved. Use the `markPending()` method with\n     * the `source` option to update the pendingStore.\n     */\n    readonly pendingStore: ReadonlySet<ControlId>;\n\n    /**\n     * More advanced-ish*\n     *\n     * A map of ControlIds and ValidatorFns. The `validator`\n     * property is composed of all the validator functions in the\n     * `validatorStore`. The validatorStore allows you to change\n     * individual validator functions on the control without\n     * affecting other validator functions on the control.\n     *\n     * When you use the `setValidators` method, you are updating\n     * the validatorStore.\n     */\n    readonly validatorStore: ReadonlyMap<ControlId, ValidatorFn>;\n  };\n\n  /**\n   * If this control is disabled, the status is `\"DISABLED\"`,\n   * else if this control is pending, the status is `\"PENDING\"`,\n   * else if this control has any errors, the status is `\"INVALID\"`,\n   * else the status is `\"VALID\"`.\n   */\n  readonly status: 'DISABLED' | 'PENDING' | 'INVALID' | 'VALID';\n\n  [AbstractControlInterface]: true;\n\n  /** set the control's value  */\n  setValue(value: RawValue): void;\n\n  /**\n   * If provided a `ValidationErrors` object or `null`, replaces `self.errors`.\n   * Optionally, provide a source ID and the change will be partitioned\n   * assocaited with the source ID. The default source ID is\n   * \"CONTROL_DEFAULT_SOURCE\".\n   *\n   * If you provide a `Map` object containing `ValidationErrors` keyed to source IDs,\n   * that will replace the `self.errorsStore` associated with this control.\n   */\n  setErrors(\n    value: ValidationErrors | null | ReadonlyMap<ControlId, ValidationErrors>,\n    options?: { source?: ControlId }\n  ): void;\n\n  /**\n   * If you provide a `ValidationErrors` object, that object is merged with the\n   * existing errors associated with the source ID. If the error object has\n   * keys equal to `null`, errors associated with those keys are deleted\n   * from the errors object.\n   *\n   * If you provide a `Map` object containing `ValidationErrors` keyed to source IDs,\n   * that object is merged with the existing `errorsStore`.\n   */\n  patchErrors(\n    value: ValidationErrors | ReadonlyMap<ControlId, ValidationErrors>,\n    options?: { source?: ControlId }\n  ): void;\n\n  /** sets `self.isTouched` */\n  markTouched(value: boolean): void;\n\n  /** sets `self.isDirty` */\n  markDirty(value: boolean): void;\n\n  /** sets `self.isReadonly` */\n  markReadonly(value: boolean): void;\n\n  /**\n   * Sets `self.isRequired`.\n   *\n   * Note that this property doesn't\n   * have any predefined meaning for IAbstractControls and it doesn't affect\n   * validation in any way. It is up to you to decide what meaning, if any,\n   * to give to this property and how to use it. For example, if you\n   * validated the control inside a `createEffect()` you could alter the\n   * validation based on whether the control was marked as `required` or\n   * not.\n   */\n  markRequired(value: boolean): void;\n\n  /**\n   * Set `self.isDisabled`.\n   *\n   * Note that `self.isDisabled`` affect's the control's `status`\n   * property. Additionally, `IAbstractControlContainer's` ignore\n   * disabled children in many cases. For example, the `value` of a\n   * control container is equal to the value of it's _enabled_ children\n   * (if you want to see the value including disabled children, use\n   * `rawValue`).\n   */\n  markDisabled(value: boolean): void;\n\n  /** sets `self.isSubmitted` */\n  markSubmitted(value: boolean): void;\n\n  /** sets `self.pendingStore` and `self.isPending` */\n  markPending(\n    value: boolean | ReadonlySet<ControlId>,\n    options?: { source?: ControlId }\n  ): void;\n\n  /** sets `validator` and `self.validatorStore` */\n  setValidators(\n    value:\n      | ValidatorFn\n      | ValidatorFn[]\n      | ReadonlyMap<ControlId, ValidatorFn>\n      | null,\n    options?: { source?: ControlId }\n  ): void;\n\n  /**\n   * The data property can store arbitrary custom data. Use the\n   * `setData` method on `IAbstractControl` to update it.\n   *\n   * The `data` property is, itself, an object. You can set individual\n   * keys on the data property with `setData` but you cannot reset\n   * or clear the whole object. This is intentional. A library\n   * maintainer can store private data within the `data` property\n   * using a symbol without fear of the user accidently erasing it.\n   */\n  setData<K extends keyof Data>(key: K, data: Data[K]): void;\n}\n","import {\n  ControlId,\n  isAbstractControl,\n  ValidationErrors,\n} from './abstract-control';\nimport { IAbstractControl } from './abstract-control';\n\n// UTILITY TYPES\n\ntype PickUndefinedKeys<T> = {\n  [K in keyof T]: undefined extends T[K] ? K : never;\n}[keyof T];\n\ntype PickRequiredKeys<T> = {\n  [K in keyof T]: undefined extends T[K] ? never : K;\n}[keyof T];\n\ntype ObjectControlsOptionalRawValue<\n  T extends { [key: string]: IAbstractControl | undefined }\n> = {\n  [P in Exclude<PickUndefinedKeys<T>, undefined>]?: NonNullable<\n    T[P]\n  >['rawValue'];\n};\n\ntype ObjectControlsRequiredRawValue<\n  T extends { [key: string]: IAbstractControl | undefined }\n> = {\n  [P in Exclude<PickRequiredKeys<T>, undefined>]: NonNullable<T[P]>['rawValue'];\n};\n\ntype ArrayControlsRawValue<T extends ReadonlyArray<IAbstractControl>> =\n  T extends ReadonlyArray<infer C>\n    ? C extends IAbstractControl\n      ? ReadonlyArray<C['rawValue']>\n      : never\n    : never;\n\ntype ObjectControlsOptionalValue<\n  T extends { [key: string]: IAbstractControl | undefined }\n> = {\n  [P in Exclude<PickUndefinedKeys<T>, undefined>]?: NonNullable<T[P]>['value'];\n};\n\ntype ObjectControlsRequiredValue<\n  T extends { [key: string]: IAbstractControl | undefined }\n> = {\n  [P in Exclude<PickRequiredKeys<T>, undefined>]: NonNullable<T[P]>['value'];\n};\n\ntype ArrayControlsValue<T extends ReadonlyArray<IAbstractControl>> =\n  T extends ReadonlyArray<infer C>\n    ? C extends IAbstractControl\n      ? ReadonlyArray<C['value']>\n      : never\n    : never;\n\n// END UTILITY TYPES\n\nexport type GenericControlsObject =\n  | {\n      readonly [key: string]: IAbstractControl;\n    }\n  | ReadonlyArray<IAbstractControl>;\n\n// need to add the `keyof ControlsRawValue<Controls>` as well as\n// `keyof ControlsValue<Controls>` as well as the `keyof Controls` etc\n// because typescript doesn't realize that all three are the same keys\n// and without all three, then ControlsKey can't be used to index all three\nexport type ControlsKey<Controls extends GenericControlsObject> =\n  keyof ControlsRawValue<Controls> &\n    keyof ControlsValue<Controls> &\n    (Controls extends ReadonlyArray<any>\n      ? keyof Controls & number\n      : Controls extends object\n      ? // the `& string` is needed or else\n        // ControlsKey<{[key: string]: AbstractControl}> is type string | number\n        keyof Controls & string\n      : any);\n\nexport type ControlsRawValue<Controls extends GenericControlsObject> =\n  Controls extends ReadonlyArray<IAbstractControl>\n    ? ArrayControlsRawValue<Controls>\n    : Controls extends { readonly [key: string]: IAbstractControl | undefined }\n    ? ObjectControlsRequiredRawValue<Controls> &\n        ObjectControlsOptionalRawValue<Controls>\n    : never;\n\nexport type ControlsValue<Controls extends GenericControlsObject> =\n  Controls extends ReadonlyArray<IAbstractControl>\n    ? ArrayControlsValue<Controls>\n    : Controls extends { readonly [key: string]: IAbstractControl | undefined }\n    ? Partial<\n        ObjectControlsRequiredValue<Controls> &\n          ObjectControlsOptionalValue<Controls>\n      >\n    : never;\n\nexport type ContainerControls<C> = C extends IAbstractControlContainer<\n  infer Controls\n>\n  ? Controls\n  : unknown;\n\nexport const AbstractControlContainerInterface =\n  '@@AbstractControlContainerInterface_solidjs';\n\n/**\n * Returns true if the provided object implements\n * `IAbstractControlContainer`\n */\nexport function isAbstractControlContainer(\n  object?: unknown\n): object is IAbstractControlContainer {\n  return (\n    isAbstractControl(object) &&\n    (object as any)[AbstractControlContainerInterface]\n  );\n}\n\nexport interface IAbstractControlContainer<\n  Controls extends GenericControlsObject = any,\n  Data = any\n> extends IAbstractControl<\n    ControlsRawValue<Controls>,\n    Data,\n    ControlsValue<Controls>\n  > {\n  /** Child controls associated with this container */\n  readonly controls: Controls;\n\n  /** The number of controls associated with this container */\n  readonly size: number;\n\n  /** Only returns values for enabled child controls. */\n  readonly value: ControlsValue<Controls>;\n\n  /**\n   * Returns values for both enabled and disabled child controls.\n   */\n  readonly rawValue: ControlsRawValue<Controls>;\n\n  /** Will return true if `this.self.isValid` and `this.children.areValid` */\n  readonly isValid: boolean;\n\n  /** Will return true if `this.self.isDisabled` or `this.children.areDisabled` */\n  readonly isDisabled: boolean;\n\n  /** Will return true if `this.self.isReadonly` or `this.children.areReadonly` */\n  readonly isReadonly: boolean;\n\n  /** Will return true if `this.self.isRequired` or `this.child.isRequired` */\n  readonly isRequired: boolean;\n\n  /** Will return true if `this.self.isPending` or `this.child.isPending` */\n  readonly isPending: boolean;\n\n  /** Will return true if `this.self.isTouched` or `this.child.isTouched` */\n  readonly isTouched: boolean;\n\n  /** Will return true if `this.self.isDirty` or `this.child.isDirty` */\n  readonly isDirty: boolean;\n\n  /** Will return true if `this.self.isSubmitted` or `this.children.areSubmitted` */\n  readonly isSubmitted: boolean;\n\n  /** Contains `{ ...this.children.errors, ...this.self.errors }` or `null` if there are none */\n  readonly errors: ValidationErrors | null;\n\n  readonly child: {\n    /** Will return true if *any* `enabled` direct child control is `valid` */\n    readonly isValid: boolean;\n    /** Will return true if *any* direct child control is `disabled` */\n    readonly isDisabled: boolean;\n    /** Will return true if *any* `enabled` direct child control is `readonly` */\n    readonly isReadonly: boolean;\n    /** Will return true if *any* `enabled` direct child control is `required` */\n    readonly isRequired: boolean;\n    /** Will return true if *any* `enabled` direct child control is `pending` */\n    readonly isPending: boolean;\n    /** Will return true if *any* `enabled` direct child control is `touched` */\n    readonly isTouched: boolean;\n    /** Will return true if *any* `enabled` direct child control is `dirty` */\n    readonly isDirty: boolean;\n    /** Will return true if *any* `enabled` direct child control is `submitted` */\n    readonly isSubmitted: boolean;\n  };\n\n  readonly children: {\n    /** Will return true if *all* `enabled` direct child control's are `valid` */\n    readonly areValid: boolean;\n    /** Will return true if *all* direct child control's are `disabled` */\n    readonly areDisabled: boolean;\n    /** Will return true if *all* `enabled` direct child control's are `readonly` */\n    readonly areReadonly: boolean;\n    /** Will return true if *all* `enabled` direct child control's are `required` */\n    readonly areRequired: boolean;\n    /** Will return true if *all* `enabled` direct child control's are `pending` */\n    readonly arePending: boolean;\n    /** Will return true if *all* `enabled` direct child control's are `touched` */\n    readonly areTouched: boolean;\n    /** Will return true if *all* `enabled` direct child control's are `dirty` */\n    readonly areDirty: boolean;\n    /** Will return true if *all* `enabled` direct child control's are `submitted` */\n    readonly areSubmitted: boolean;\n    /** Contains *all* `enabled` child control errors or `null` if there are none */\n    readonly errors: ValidationErrors | null;\n\n    /**\n     * Mark all direct children as disabled. Use the `deep: true`\n     * option to instead mark all direct and indirect children\n     * as disabled.\n     */\n    markDisabled(value: boolean, options?: { deep?: boolean }): void;\n\n    /**\n     * Mark all direct children as touched. Use the `deep: true`\n     * option to instead mark all direct and indirect children\n     * as touched.\n     */\n    markTouched(value: boolean, options?: { deep?: boolean }): void;\n\n    /**\n     * Mark all direct children as dirty. Use the `deep: true`\n     * option to instead mark all direct and indirect children\n     * as dirty.\n     */\n    markDirty(value: boolean, options?: { deep?: boolean }): void;\n\n    /**\n     * Mark all direct children as readonly. Use the `deep: true`\n     * option to instead mark all direct and indirect children\n     * as readonly.\n     */\n    markReadonly(value: boolean, options?: { deep?: boolean }): void;\n\n    /**\n     * Mark all direct children as required. Use the `deep: true`\n     * option to instead mark all direct and indirect children\n     * as required.\n     */\n    markRequired(value: boolean, options?: { deep?: boolean }): void;\n\n    /**\n     * Mark all direct children as submitted. Use the `deep: true`\n     * option to instead mark all direct and indirect children\n     * as submitted.\n     */\n    markSubmitted(value: boolean, options?: { deep?: boolean }): void;\n\n    /**\n     * Mark all direct children as pending. Use the `deep: true`\n     * option to instead mark all direct and indirect children\n     * as pending.\n     */\n    markPending(\n      value: boolean,\n      options?: { source?: ControlId; deep?: boolean }\n    ): void;\n  };\n\n  [AbstractControlContainerInterface]: true;\n\n  /**\n   * Apply a partial update to the values of some children but\n   * not all.\n   */\n  patchValue(value: unknown): void;\n\n  /** sets the `controls` property */\n  setControls(controls: Controls): void;\n\n  /** stores the provided control in `controls[key]` */\n  setControl(key: unknown, control: unknown): void;\n\n  /**\n   * If provided a control value, removes the given control from\n   * `controls`. If provided a control key value, removes the\n   * control associated with the given key from `controls`.\n   */\n  removeControl(keyOrControl: unknown): void;\n}\n","import _isEqual from 'deep-equal';\nimport { getOwner, runWithOwner } from 'solid-js';\nimport type { Merge } from 'type-fest';\n\nexport function isEqual<T>(a: T, b: any): b is T {\n  return _isEqual(a, b);\n}\n\nexport function mergeObj<A, B>(a: A, b: Merge<Partial<A>, B>): Merge<A, B> {\n  return Object.defineProperties(\n    a,\n    Object.getOwnPropertyDescriptors(b)\n  ) as unknown as Merge<A, B>;\n}\n\n/**\n * Helper to bind the owner of the current context to the\n * supplied function.\n *\n * Implementation is very simple:\n * ```ts\n * import { getOwner, runWithOwner } from 'solid-js';\n *\n * export function bindOwner<T>(fn: () => T): () => T {\n *   const owner = getOwner();\n *\n *   if (!owner) {\n *     throw new Error('No solidjs owner in current context');\n *   }\n *\n *   return () => runWithOwner(owner, fn);\n * }\n * ```\n */\nexport function bindOwner<T>(fn: () => T): () => T {\n  const owner = getOwner();\n\n  if (!owner) {\n    throw new Error('No solidjs owner in current context');\n  }\n\n  return () => runWithOwner(owner, fn);\n}\n","import type {\n  ValidatorFn,\n  ValidationErrors,\n  ControlId,\n  AbstractControlInterface,\n} from './abstract-control';\nimport { IAbstractControl } from './abstract-control';\nimport { produce, SetStoreFunction, Store } from 'solid-js/store';\nimport {\n  Accessor,\n  createComputed,\n  createMemo,\n  createSignal,\n  on,\n} from 'solid-js';\nimport { isEqual } from './util';\n\nexport const DEFAULT_SOURCE = 'CONTROL_DEFAULT_SOURCE';\n\nexport interface IAbstractControlBaseOptions<\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> {\n  id?: ControlId;\n  data?: Data;\n  disabled?: boolean;\n  touched?: boolean;\n  dirty?: boolean;\n  readonly?: boolean;\n  required?: boolean;\n  submitted?: boolean;\n  errors?: null | ValidationErrors | ReadonlyMap<ControlId, ValidationErrors>;\n  validators?:\n    | null\n    | ValidatorFn\n    | ValidatorFn[]\n    | ReadonlyMap<ControlId, ValidatorFn>;\n  pending?: boolean | ReadonlySet<ControlId>;\n}\n\nexport function propInitializer(): [\n  propInitializing: <T>(value: T) => T,\n  initComplete: () => void\n] {\n  const [initializationSignal, setInitializationSignal] = createSignal<\n    null | false\n  >(null);\n\n  return [\n    <T>(value: T) => initializationSignal() || value,\n    () => setInitializationSignal(false),\n  ];\n}\n\nexport function composeValidators(\n  validators: undefined | null | ValidatorFn | ValidatorFn[]\n): null | ValidatorFn {\n  if (!validators || (Array.isArray(validators) && validators.length === 0)) {\n    return null;\n  }\n\n  if (Array.isArray(validators)) {\n    return (control) =>\n      validators.reduce((prev: ValidationErrors | null, curr: ValidatorFn) => {\n        const errors = curr(control);\n        return errors ? { ...prev, ...errors } : prev;\n      }, null);\n  }\n\n  return validators;\n}\n\nexport type IAbstractControlBase<\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> = Omit<\n  IAbstractControl<unknown, Data, unknown>,\n  'value' | 'rawValue' | 'setValue' | typeof AbstractControlInterface\n>;\n\nlet controlId = 0;\n\nexport function createAbstractControlBase<\n  RawValue,\n  Data extends Record<ControlId, any> = Record<ControlId, any>,\n  Value = RawValue\n>(\n  store: Accessor<\n    [\n      Store<IAbstractControl<RawValue, Data, Value>>,\n      SetStoreFunction<IAbstractControl<RawValue, Data, Value>>\n    ]\n  >,\n  untilInit: <T>(value: T) => T,\n  initOptions: Pick<IAbstractControlBaseOptions<Data>, 'id' | 'data'> = {}\n): [base: IAbstractControlBase<Data>, initializer: () => void] {\n  let control: Store<IAbstractControl<RawValue, Data, Value>>;\n  let setControl: SetStoreFunction<IAbstractControl<RawValue, Data, Value>>;\n\n  let selfIsPendingMemo: Accessor<IAbstractControl['self']['isPending']>;\n  let selfErrorsMemo: Accessor<ValidationErrors | null>;\n  let statusMemo: Accessor<IAbstractControl['status']>;\n  let validatorMemo: Accessor<IAbstractControl['validator']>;\n\n  const base: IAbstractControlBase<Data> = {\n    id: initOptions.id || Symbol(`AbstractControl-${controlId++}`),\n\n    data: { ...(initOptions.data as Data) },\n\n    self: {\n      get isValid() {\n        // here \"this\" is self\n        return this.errors === null && !this.isPending;\n      },\n      isDisabled: false,\n      isTouched: false,\n      isDirty: false,\n      isReadonly: false,\n      isSubmitted: false,\n      isRequired: false,\n      get isPending() {\n        return selfIsPendingMemo?.() ?? untilInit(false);\n      },\n      get errors() {\n        return selfErrorsMemo?.() ?? untilInit(null);\n      },\n      errorsStore: new Map(),\n      pendingStore: new Set(),\n      validatorStore: new Map(),\n    },\n\n    get isDisabled() {\n      return this.self.isDisabled;\n    },\n\n    get isTouched() {\n      return this.self.isTouched;\n    },\n\n    get isDirty() {\n      return this.self.isDirty;\n    },\n\n    get isReadonly() {\n      return this.self.isReadonly;\n    },\n\n    get isSubmitted() {\n      return this.self.isSubmitted;\n    },\n\n    get isRequired() {\n      return this.self.isRequired;\n    },\n\n    get errors() {\n      return this.self.errors;\n    },\n\n    get isPending() {\n      return this.self.isPending;\n    },\n\n    get isValid() {\n      return this.self.isValid;\n    },\n\n    get status() {\n      return statusMemo?.() ?? untilInit('VALID');\n    },\n\n    get validator() {\n      return validatorMemo?.() ?? untilInit(null);\n    },\n\n    markDisabled(input) {\n      if (isEqual(this.self.isDisabled, input)) return;\n      setControl('self', 'isDisabled', input);\n    },\n\n    markReadonly(input) {\n      if (isEqual(this.self.isReadonly, input)) return;\n      setControl('self', 'isReadonly', input);\n    },\n\n    markRequired(input) {\n      if (isEqual(this.self.isRequired, input)) return;\n      setControl('self', 'isRequired', input);\n    },\n\n    markDirty(input) {\n      if (isEqual(this.self.isDirty, input)) return;\n      setControl('self', 'isDirty', input);\n    },\n\n    markTouched(input) {\n      if (isEqual(this.self.isTouched, input)) return;\n      setControl('self', 'isTouched', input);\n    },\n\n    markSubmitted(input) {\n      if (isEqual(this.self.isSubmitted, input)) return;\n      setControl('self', 'isSubmitted', input);\n    },\n\n    markPending(input, options) {\n      let newPendingStore: Set<ControlId>;\n\n      if (typeof input === 'boolean') {\n        const source = options?.source || DEFAULT_SOURCE;\n\n        if (this.self.pendingStore.has(source) === input) return;\n\n        newPendingStore = new Set(this.self.pendingStore);\n\n        if (input) {\n          newPendingStore.add(source);\n        } else {\n          newPendingStore.delete(source);\n        }\n      } else {\n        if (this.self.pendingStore === input) return;\n\n        newPendingStore = new Set(input);\n      }\n\n      if (isEqual(this.self.pendingStore, newPendingStore)) return;\n\n      // We're using `produce()` here because using the standard solid Store\n      // nested setter has some bugs (i.e.\n      // `setControl('self', 'pendingStore', newPendingStore)`). I think the\n      // bugs are isolated to object values, so, at the moment, I'm only using\n      // produce where the value is an object.\n      setControl(\n        produce((state) => {\n          (state.self.pendingStore as Set<ControlId>) = newPendingStore;\n        })\n      );\n    },\n\n    setErrors(input, options) {\n      const source = options?.source || DEFAULT_SOURCE;\n\n      const existingStore = this.self.errorsStore;\n\n      let newErrorsStore: Map<ControlId, ValidationErrors>;\n\n      if (input instanceof Map) {\n        newErrorsStore = input;\n      } else if (input === null || Object.keys(input).length === 0) {\n        newErrorsStore = new Map(existingStore);\n        newErrorsStore.delete(source);\n      } else {\n        newErrorsStore = new Map(existingStore).set(source, input);\n      }\n\n      if (isEqual(this.self.errorsStore, newErrorsStore)) return;\n\n      // We're using `produce()` here because using the standard solid Store\n      // nested setter has some bugs (i.e.\n      // `setControl('self', 'pendingStore', newPendingStore)`). I think the\n      // bugs are isolated to object values, so, at the moment, I'm only using\n      // produce where the value is an object.\n      setControl(\n        produce((state) => {\n          (state.self.errorsStore as Map<ControlId, ValidationErrors>) =\n            newErrorsStore;\n        })\n      );\n    },\n\n    patchErrors(input, options) {\n      const existingStore = this.self.errorsStore as Map<\n        ControlId,\n        ValidationErrors\n      >;\n\n      if (input instanceof Map) {\n        // We're using `produce()` here because using the standard solid Store\n        // nested setter has some bugs (i.e.\n        // `setControl('self', 'pendingStore', newPendingStore)`). I think the\n        // bugs are isolated to object values, so, at the moment, I'm only using\n        // produce where the value is an object.\n        setControl(\n          produce((state) => {\n            (state.self.errorsStore as Map<ControlId, ValidationErrors>) =\n              new Map([...existingStore, ...input]);\n          })\n        );\n      } else {\n        if (Object.keys(input).length === 0) return;\n\n        const source = options?.source || DEFAULT_SOURCE;\n\n        let newErrors: ValidationErrors = input;\n\n        let existingValue = existingStore.get(source);\n\n        if (existingValue) {\n          existingValue = { ...existingValue };\n\n          for (const [k, err] of Object.entries(newErrors)) {\n            if (err === null) {\n              delete existingValue![k];\n            } else {\n              existingValue![k] = err;\n            }\n          }\n\n          newErrors = existingValue;\n        } else {\n          const entries = Object.entries(newErrors).filter(\n            ([, v]) => v !== null\n          );\n\n          if (entries.length === 0) return;\n\n          newErrors = Object.fromEntries(entries);\n        }\n\n        const newErrorsStore = new Map(existingStore);\n\n        if (Object.keys(newErrors).length === 0) {\n          newErrorsStore.delete(source);\n        } else {\n          newErrorsStore.set(source, newErrors);\n        }\n\n        if (isEqual(this.self.errorsStore, newErrorsStore)) return;\n\n        // We're using `produce()` here because using the standard solid Store\n        // nested setter has some bugs (i.e.\n        // `setControl('self', 'pendingStore', newPendingStore)`). I think the\n        // bugs are isolated to object values, so, at the moment, I'm only using\n        // produce where the value is an object.\n        setControl(\n          produce((state) => {\n            (state.self.errorsStore as Map<ControlId, ValidationErrors>) =\n              newErrorsStore;\n          })\n        );\n      }\n    },\n\n    setValidators(input, options) {\n      const source = options?.source || DEFAULT_SOURCE;\n\n      let newValidatorsStore: Map<ControlId, ValidatorFn>;\n\n      if (input instanceof Map) {\n        newValidatorsStore = new Map(input);\n      } else {\n        newValidatorsStore = new Map(\n          this.self.validatorStore as Map<ControlId, ValidatorFn>\n        );\n\n        const newValidator = composeValidators(\n          input as Exclude<typeof input, ReadonlyMap<any, any>>\n        );\n\n        if (newValidator) {\n          newValidatorsStore.set(source, newValidator);\n        } else {\n          newValidatorsStore.delete(source);\n        }\n      }\n\n      if (isEqual(this.self.validatorStore, newValidatorsStore)) return;\n\n      // We're using `produce()` here because using the standard solid Store\n      // nested setter has some bugs (i.e.\n      // `setControl('self', 'pendingStore', newPendingStore)`). I think the\n      // bugs are isolated to object values, so, at the moment, I'm only using\n      // produce where the value is an object.\n      setControl(\n        produce((state) => {\n          (state.self.validatorStore as Map<ControlId, ValidatorFn<any>>) =\n            newValidatorsStore;\n        })\n      );\n    },\n\n    setData(key, input) {\n      if (isEqual(this.data[key], input)) return;\n      // We're using `produce()` here because using the standard solid Store\n      // nested setter has some bugs (i.e.\n      // `setControl('self', 'pendingStore', newPendingStore)`). I think the\n      // bugs are isolated to object values, so, at the moment, I'm only using\n      // produce where the value is an object.\n      setControl(\n        produce((state) => {\n          state.data[key] = input;\n        })\n      );\n    },\n  };\n\n  const initializer = () => {\n    [control, setControl] = store();\n\n    selfIsPendingMemo = createMemo(() => control.self.pendingStore.size > 0);\n\n    selfErrorsMemo = createMemo(() => {\n      return control.self.errorsStore.size === 0\n        ? null\n        : Array.from(\n            control.self.errorsStore.values()\n          ).reduce<ValidationErrors>(\n            (p, errors) => ({\n              ...p,\n              ...errors,\n            }),\n            {}\n          );\n    });\n\n    statusMemo = createMemo(() => {\n      return control.isDisabled\n        ? 'DISABLED'\n        : control.isPending\n        ? 'PENDING'\n        : control.isValid\n        ? 'VALID'\n        : 'INVALID';\n    });\n\n    validatorMemo = createMemo(() => {\n      if (control.self.validatorStore.size === 0) return null;\n\n      const validators = Array.from(control.self.validatorStore.values());\n\n      return (c) => {\n        const e = validators.reduce<ValidationErrors>((err, v) => {\n          return { ...err, ...v(c) };\n        }, {});\n\n        return Object.keys(e).length === 0 ? null : e;\n      };\n    });\n\n    // Intentionally not using `createRenderEffect()` since it appears to\n    // mess with initializing a control with errors (i.e. it clears the errors\n    // after the control is initialized)\n    createComputed(\n      on(\n        () => control.validator?.(control.rawValue) ?? null,\n        (errors) => {\n          if (control.self.errorsStore.get(DEFAULT_SOURCE) === errors) return;\n\n          const newErrorsStore = new Map(\n            control.self.errorsStore as Map<ControlId, ValidationErrors>\n          );\n\n          if (errors) {\n            newErrorsStore.set(DEFAULT_SOURCE, errors);\n          } else {\n            newErrorsStore.delete(DEFAULT_SOURCE);\n          }\n\n          if (isEqual(control.self.errorsStore, newErrorsStore)) return;\n\n          // We're using `produce()` here because using the standard solid Store\n          // nested setter has some bugs (i.e.\n          // `setControl('self', 'pendingStore', newPendingStore)`). I think the\n          // bugs are isolated to object values, so, at the moment, I'm only using\n          // produce where the value is an object.\n          setControl(\n            produce((state) => {\n              (state.self.errorsStore as Map<ControlId, ValidationErrors>) =\n                newErrorsStore;\n            })\n          );\n        }\n      )\n    );\n  };\n\n  return [base, initializer];\n}\n","import { createStore, produce, SetStoreFunction, Store } from 'solid-js/store';\nimport {\n  IAbstractControl,\n  ControlId,\n  AbstractControlInterface,\n  isAbstractControl,\n} from './abstract-control';\nimport {\n  IAbstractControlBaseOptions,\n  createAbstractControlBase,\n  propInitializer,\n} from './abstract-control-base';\nimport { isEqual, mergeObj } from './util';\n\nexport const FormControlInterface = '@@FormControlInterface_solidjs';\n\nexport interface IFormControlOptions<\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> extends IAbstractControlBaseOptions<Data> {}\n\nexport interface IFormControl<\n  Value = any,\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> extends IAbstractControl<Value, Data, Value> {\n  [FormControlInterface]: true;\n}\n\n/**\n * Returns true if the provided object implements\n * `IFormControl`\n */\nexport function isFormControl(object?: unknown): object is IFormControl {\n  return (\n    isAbstractControl(object) &&\n    (object as any)?.[FormControlInterface] === true\n  );\n}\n\nexport function createFormControl<\n  Value,\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n>(\n  value?: Value,\n  options?: IFormControlOptions<Data>\n): IFormControl<Value, Data>;\nexport function createFormControl<\n  Value,\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n>(\n  initValue?: Value,\n  initOptions: IFormControlOptions<Data> = {}\n): IFormControl<Value, Data> {\n  let control: Store<IFormControl<Value, Data>>;\n  let setControl: SetStoreFunction<IFormControl<Value, Data>>;\n\n  const [untilInit, initComplete] = propInitializer();\n\n  const [base, initializeBase] = createAbstractControlBase<Value, Data, Value>(\n    () => [control, setControl],\n    untilInit,\n    initOptions\n  );\n\n  const storeConfig = mergeObj(base, {\n    [AbstractControlInterface]: true,\n    [FormControlInterface]: true,\n\n    rawValue: initValue as Value,\n\n    get value() {\n      return this.rawValue;\n    },\n\n    setValue(value) {\n      if (isEqual(this.value, value)) return;\n\n      // We're using `produce()` here because using the standard solid Store\n      // nested setter has some bugs (i.e.\n      // `setControl('self', 'pendingStore', newPendingStore)`). I think the\n      // bugs are isolated to object values, so, at the moment, I'm only using\n      // produce where the value could be an object.\n      setControl(\n        produce((state) => {\n          (state.rawValue as Value) = value;\n        })\n      );\n    },\n  } as IFormControl<Value, Data>);\n\n  [control, setControl] = createStore<IFormControl<Value, Data>>(storeConfig);\n\n  initializeBase();\n  initComplete();\n\n  // Intentionally not using `batch()` since it appears to mess with\n  // initializing a control with errors\n  if (initOptions.disabled) control.markDisabled(initOptions.disabled);\n  if (initOptions.touched) control.markTouched(initOptions.touched);\n  if (initOptions.dirty) control.markDirty(initOptions.dirty);\n  if (initOptions.readonly) control.markReadonly(initOptions.readonly);\n  if (initOptions.submitted) control.markSubmitted(initOptions.submitted);\n  if (initOptions.required) control.markRequired(initOptions.required);\n  if (initOptions.pending) control.markPending(initOptions.pending);\n  if (initOptions.validators) control.setValidators(initOptions.validators);\n  if (initOptions.pending) control.markPending(initOptions.pending);\n  // this needs to be last to ensure that the errors aren't overwritten\n  if (initOptions.errors) control.patchErrors(initOptions.errors);\n\n  return control as unknown as IFormControl<Value, Data>;\n}\n","import {\n  AbstractControlInterface,\n  ControlId,\n  isAbstractControl,\n  ValidationErrors,\n} from './abstract-control';\n\nimport { IAbstractControl } from './abstract-control';\n\nimport {\n  AbstractControlContainerInterface,\n  ControlsKey,\n  ControlsRawValue,\n  ControlsValue,\n  GenericControlsObject,\n  isAbstractControlContainer,\n} from './abstract-control-container';\n\nimport { IAbstractControlContainer } from './abstract-control-container';\n\nimport {\n  createAbstractControlBase,\n  IAbstractControlBaseOptions,\n} from './abstract-control-base';\n\nimport { produce, SetStoreFunction, Store } from 'solid-js/store';\nimport { Accessor, batch, createMemo } from 'solid-js';\nimport { isEqual, mergeObj } from './util';\nimport type { PartialDeep } from 'type-fest';\n\nexport interface IAbstractControlContainerBaseArgs<\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> extends IAbstractControlBaseOptions<Data> {}\n\nexport interface IAbstractControlContainerBase<\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> extends Omit<\n    IAbstractControlContainer<any, Data>,\n    | 'value'\n    | 'rawValue'\n    | 'controls'\n    | 'setControl'\n    | typeof AbstractControlInterface\n    | typeof AbstractControlContainerInterface\n  > {}\n\nexport function createAbstractControlContainerBase<\n  Controls extends GenericControlsObject = any,\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n>(\n  store: Accessor<\n    [\n      Store<IAbstractControlContainer<Controls, Data>>,\n      SetStoreFunction<IAbstractControlContainer<Controls, Data>>\n    ]\n  >,\n  untilInit: <T>(value: T) => T,\n  initOptions: IAbstractControlContainerBaseArgs<Data> = {}\n): [base: IAbstractControlContainerBase<Data>, initializer: () => void] {\n  let control: Store<IAbstractControlContainer<Controls, Data>>;\n  let setControl: SetStoreFunction<IAbstractControlContainer<Controls, Data>>;\n\n  const [base, initializeAbstractControl] = createAbstractControlBase<\n    ControlsRawValue<Controls>,\n    Data,\n    ControlsValue<Controls>\n  >(() => [control, setControl], untilInit, initOptions);\n\n  let sizeMemo: Accessor<number>;\n\n  let childIsValidMemo: Accessor<boolean>;\n  let childIsDisabledMemo: Accessor<boolean>;\n  let childIsReadonlyMemo: Accessor<boolean>;\n  let childIsRequiredMemo: Accessor<boolean>;\n  let childIsPendingMemo: Accessor<boolean>;\n  let childIsTouchedMemo: Accessor<boolean>;\n  let childIsDirtyMemo: Accessor<boolean>;\n  let childIsSubmittedMemo: Accessor<boolean>;\n\n  let childrenAreValidMemo: Accessor<boolean>;\n  let childrenAreDisabledMemo: Accessor<boolean>;\n  let childrenAreReadonlyMemo: Accessor<boolean>;\n  let childrenAreRequiredMemo: Accessor<boolean>;\n  let childrenArePendingMemo: Accessor<boolean>;\n  let childrenAreTouchedMemo: Accessor<boolean>;\n  let childrenAreDirtyMemo: Accessor<boolean>;\n  let childrenAreSubmittedMemo: Accessor<boolean>;\n\n  let errorsMemo: Accessor<ValidationErrors | null>;\n  let childrenErrorsMemo: Accessor<ValidationErrors | null>;\n\n  const containerBase = mergeObj(base, {\n    get size() {\n      return sizeMemo?.() ?? untilInit(0);\n    },\n\n    get isDisabled() {\n      return this.self.isDisabled || this.children.areDisabled;\n    },\n\n    get isTouched() {\n      return this.self.isTouched || this.child.isTouched;\n    },\n\n    get isDirty() {\n      return this.self.isDirty || this.child.isDirty;\n    },\n\n    get isReadonly() {\n      return this.self.isReadonly || this.children.areReadonly;\n    },\n\n    get isSubmitted() {\n      return this.self.isSubmitted || this.children.areSubmitted;\n    },\n\n    get isRequired() {\n      return this.self.isRequired || this.child.isRequired;\n    },\n\n    get isPending() {\n      return this.self.isPending || this.child.isPending;\n    },\n\n    get errors() {\n      return errorsMemo?.() ?? untilInit(null);\n    },\n\n    get isValid() {\n      return this.self.isValid && this.children.areValid;\n    },\n\n    child: {\n      /** Will return true if *any* `enabled` direct child control is `valid` */\n      get isValid() {\n        return childIsValidMemo?.() ?? untilInit(true);\n      },\n      /** Will return true if *any* direct child control is `disabled` */\n      get isDisabled() {\n        return childIsDisabledMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *any* `enabled` direct child control is `readonly` */\n      get isReadonly() {\n        return childIsReadonlyMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *any* `enabled` direct child control is `required` */\n      get isRequired() {\n        return childIsRequiredMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *any* `enabled` direct child control is `pending` */\n      get isPending() {\n        return childIsPendingMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *any* `enabled` direct child control is `touched` */\n      get isTouched() {\n        return childIsTouchedMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *any* `enabled` direct child control is `dirty` */\n      get isDirty() {\n        return childIsDirtyMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *any* `enabled` direct child control is `submitted` */\n      get isSubmitted() {\n        return childIsSubmittedMemo?.() ?? untilInit(false);\n      },\n    },\n\n    children: {\n      /** Will return true if *all* `enabled` direct child control's are `valid` */\n      get areValid() {\n        return childrenAreValidMemo?.() ?? untilInit(true);\n      },\n      /** Will return true if *all* direct child control's are `disabled` */\n      get areDisabled() {\n        return childrenAreDisabledMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *all* `enabled` direct child control's are `readonly` */\n      get areReadonly() {\n        return childrenAreReadonlyMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *all* `enabled` direct child control's are `required` */\n      get areRequired() {\n        return childrenAreRequiredMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *all* `enabled` direct child control's are `pending` */\n      get arePending() {\n        return childrenArePendingMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *all* `enabled` direct child control's are `touched` */\n      get areTouched() {\n        return childrenAreTouchedMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *all* `enabled` direct child control's are `dirty` */\n      get areDirty() {\n        return childrenAreDirtyMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *all* `enabled` direct child control's are `submitted` */\n      get areSubmitted() {\n        return childrenAreSubmittedMemo?.() ?? untilInit(false);\n      },\n      /** Contains *all* `enabled` child control errors or `null` if there are none */\n      get errors() {\n        return childrenErrorsMemo?.() ?? untilInit(null);\n      },\n\n      markDirty(value, options) {\n        batch(() => {\n          Object.values(control.controls).forEach((c) => {\n            (c as IAbstractControl).markDirty(value);\n\n            if (!options?.deep || !isAbstractControlContainer(c)) {\n              return;\n            }\n\n            c.children.markDirty(value, options);\n          });\n        });\n      },\n\n      markDisabled(value, options) {\n        batch(() => {\n          Object.values(control.controls).forEach((c) => {\n            (c as IAbstractControl).markDisabled(value);\n\n            if (!options?.deep || !isAbstractControlContainer(c)) {\n              return;\n            }\n\n            c.children.markDisabled(value, options);\n          });\n        });\n      },\n\n      markPending(value, options) {\n        batch(() => {\n          Object.values(control.controls).forEach((c) => {\n            (c as IAbstractControl).markPending(value, options);\n\n            if (!options?.deep || !isAbstractControlContainer(c)) {\n              return;\n            }\n\n            c.children.markPending(value, options);\n          });\n        });\n      },\n\n      markReadonly(value, options) {\n        batch(() => {\n          Object.values(control.controls).forEach((c) => {\n            (c as IAbstractControl).markReadonly(value);\n\n            if (!options?.deep || !isAbstractControlContainer(c)) {\n              return;\n            }\n\n            c.children.markReadonly(value, options);\n          });\n        });\n      },\n\n      markRequired(value, options) {\n        batch(() => {\n          Object.values(control.controls).forEach((c) => {\n            (c as IAbstractControl).markRequired(value);\n\n            if (!options?.deep || !isAbstractControlContainer(c)) {\n              return;\n            }\n\n            c.children.markRequired(value, options);\n          });\n        });\n      },\n\n      markSubmitted(value, options) {\n        batch(() => {\n          Object.values(control.controls).forEach((c) => {\n            (c as IAbstractControl).markSubmitted(value);\n\n            if (!options?.deep || !isAbstractControlContainer(c)) {\n              return;\n            }\n\n            c.children.markSubmitted(value, options);\n          });\n        });\n      },\n\n      markTouched(value, options) {\n        batch(() => {\n          Object.values(control.controls).forEach((c) => {\n            (c as IAbstractControl).markTouched(value);\n\n            if (!options?.deep || !isAbstractControlContainer(c)) {\n              return;\n            }\n\n            c.children.markTouched(value, options);\n          });\n        });\n      },\n    },\n\n    setControls(controls: Controls) {\n      if (isEqual(control.controls, controls)) return;\n\n      // We're using `produce()` here because using the standard solid Store\n      // nested setter has some bugs (i.e.\n      // `setControl('self', 'pendingStore', newPendingStore)`). I think the\n      // bugs are isolated to object values, so, at the moment, I'm only using\n      // produce where the value is an object.\n      setControl(\n        produce((state) => {\n          (state.controls as Controls) = controls;\n        })\n      );\n    },\n\n    /**\n     * The provided control is removed from this FormGroup\n     * if it is a child of this FormGroup. Or the control\n     * associated with the provided key is removed.\n     */\n    removeControl(\n      keyOrControl: ControlsKey<Controls> | Controls[ControlsKey<Controls>]\n    ) {\n      if (!isAbstractControl(keyOrControl)) {\n        control.setControl(keyOrControl as ControlsKey<Controls>, null);\n        return;\n      }\n\n      const childControl = keyOrControl;\n\n      for (const [key, c] of Object.entries(control.controls!)) {\n        if (c !== childControl) continue;\n\n        control.setControl(key as ControlsKey<Controls>, null);\n        return;\n      }\n    },\n\n    setValue(value: ControlsRawValue<Controls>) {\n      const valueEntries = Object.entries(value);\n\n      if (valueEntries.length !== control.size!) {\n        throw new Error(\n          `setValue error: you must provide a value for each control.`\n        );\n      }\n\n      batch(() => {\n        for (const [key, val] of valueEntries) {\n          const c = control.controls[\n            key as ControlsKey<Controls>\n          ] as unknown as IAbstractControl | undefined;\n\n          if (!c) {\n            throw new Error(`Invalid setValue value key \"${key}\".`);\n          }\n\n          c.setValue(val);\n        }\n      });\n    },\n\n    patchValue(value: PartialDeep<ControlsRawValue<Controls>>) {\n      batch(() => {\n        for (const [key, entryValue] of Object.entries(value)) {\n          const c = control.controls[\n            key as ControlsKey<Controls>\n          ] as unknown as IAbstractControl | undefined;\n\n          if (!c) {\n            throw new Error(`Invalid patchValue value key \"${key}\".`);\n          }\n\n          if (isAbstractControlContainer(c)) {\n            c.patchValue(entryValue);\n          } else {\n            c.setValue(entryValue);\n          }\n        }\n      });\n    },\n  } as IAbstractControlContainerBase<Data>);\n\n  const initializer = () => {\n    [control, setControl] = store();\n\n    initializeAbstractControl();\n\n    const allControlsMemo = createMemo(() => Object.values(control.controls));\n\n    const nonDisabledControlsMemo = createMemo(() =>\n      allControlsMemo().filter((c) => !c.isDisabled)\n    );\n\n    sizeMemo = createMemo(() => allControlsMemo().length);\n\n    childIsValidMemo = createMemo(() =>\n      nonDisabledControlsMemo().some((c) => c.isValid)\n    );\n\n    childIsDisabledMemo = createMemo(() =>\n      allControlsMemo().some((c) => c.isDisabled)\n    );\n\n    childIsReadonlyMemo = createMemo(() =>\n      nonDisabledControlsMemo().some((c) => c.isReadonly)\n    );\n\n    childIsRequiredMemo = createMemo(() =>\n      nonDisabledControlsMemo().some((c) => c.isRequired)\n    );\n\n    childIsPendingMemo = createMemo(() =>\n      nonDisabledControlsMemo().some((c) => c.isPending)\n    );\n\n    childIsTouchedMemo = createMemo(() =>\n      nonDisabledControlsMemo().some((c) => c.isTouched)\n    );\n\n    childIsDirtyMemo = createMemo(() =>\n      nonDisabledControlsMemo().some((c) => c.isDirty)\n    );\n\n    childIsSubmittedMemo = createMemo(() =>\n      nonDisabledControlsMemo().some((c) => c.isSubmitted)\n    );\n\n    childrenAreValidMemo = createMemo(() =>\n      nonDisabledControlsMemo().every((c) => c.isValid)\n    );\n\n    childrenAreDisabledMemo = createMemo(() => {\n      const controls = allControlsMemo();\n\n      if (controls.length === 0) return false;\n\n      return controls.every((c) => c.isDisabled);\n    });\n\n    childrenAreReadonlyMemo = createMemo(() => {\n      const controls = nonDisabledControlsMemo();\n\n      if (controls.length === 0) return false;\n\n      return controls.every((c) => c.isReadonly);\n    });\n\n    childrenAreRequiredMemo = createMemo(() => {\n      const controls = nonDisabledControlsMemo();\n\n      if (controls.length === 0) return false;\n\n      return controls.every((c) => c.isRequired);\n    });\n\n    childrenArePendingMemo = createMemo(() => {\n      const controls = nonDisabledControlsMemo();\n\n      if (controls.length === 0) return false;\n\n      return controls.every((c) => c.isPending);\n    });\n\n    childrenAreTouchedMemo = createMemo(() => {\n      const controls = nonDisabledControlsMemo();\n\n      if (controls.length === 0) return false;\n\n      return controls.every((c) => c.isTouched);\n    });\n\n    childrenAreDirtyMemo = createMemo(() => {\n      const controls = nonDisabledControlsMemo();\n\n      if (controls.length === 0) return false;\n\n      return controls.every((c) => c.isDirty);\n    });\n\n    childrenAreSubmittedMemo = createMemo(() => {\n      const controls = nonDisabledControlsMemo();\n\n      if (controls.length === 0) return false;\n\n      return controls.every((c) => c.isSubmitted);\n    });\n\n    errorsMemo = createMemo(() => {\n      if (!control.self.errors && !control.children.errors) return null;\n\n      return {\n        ...control.children.errors,\n        ...control.self.errors,\n      };\n    });\n\n    childrenErrorsMemo = createMemo(() => {\n      const controls = nonDisabledControlsMemo();\n\n      return controls.reduce((prev, curr) => {\n        return prev === null && curr.errors === null\n          ? null\n          : { ...prev, ...curr.errors };\n      }, null as ValidationErrors | null);\n    });\n  };\n\n  return [containerBase, initializer];\n}\n","import {\n  AbstractControlInterface,\n  ControlId,\n  IAbstractControl,\n} from './abstract-control';\nimport { createAbstractControlContainerBase } from './abstract-control-container-base';\nimport {\n  ControlsValue,\n  ControlsRawValue,\n  ControlsKey,\n  IAbstractControlContainer,\n  AbstractControlContainerInterface,\n  isAbstractControlContainer,\n} from './abstract-control-container';\nimport {\n  IAbstractControlBaseOptions,\n  propInitializer,\n} from './abstract-control-base';\nimport { createStore, produce, SetStoreFunction, Store } from 'solid-js/store';\nimport { Accessor, createMemo } from 'solid-js';\nimport { isEqual, mergeObj } from './util';\nimport type { PartialDeep } from 'type-fest';\n\nexport const FormGroupInterface = '@@FormGroupInterface_solidjs';\n\nexport interface IFormGroupOptions<\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> extends IAbstractControlBaseOptions<Data> {}\n\nexport interface IFormGroup<\n  Controls extends { [key: string]: IAbstractControl } = {\n    [key: string]: IAbstractControl;\n  },\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> extends IAbstractControlContainer<Controls, Data> {\n  [FormGroupInterface]: true;\n  setControls(controls: Controls): void;\n  removeControl(\n    keyOrControl: ControlsKey<Controls> | Controls[ControlsKey<Controls>]\n  ): void;\n  patchValue(value: PartialDeep<ControlsRawValue<Controls>>): void;\n}\n\n/**\n * Returns true if the provided object implements\n * `IFormGroup`\n */\nexport function isFormGroup(object?: unknown): object is IFormGroup {\n  return (\n    isAbstractControlContainer(object) &&\n    (object as any)?.[FormGroupInterface] === true\n  );\n}\n\nexport function createFormGroup<\n  Controls extends { [key: string]: IAbstractControl } = {\n    [key: string]: IAbstractControl;\n  },\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n>(\n  controls?: Controls,\n  options?: IFormGroupOptions<Data>\n): IFormGroup<Controls, Data>;\nexport function createFormGroup<\n  Controls extends { [key: string]: IAbstractControl } = {\n    [key: string]: IAbstractControl;\n  },\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n>(\n  initControls = {} as Controls,\n  initOptions: IFormGroupOptions<Data> = {}\n): IFormGroup<Controls, Data> {\n  let control: Store<IFormGroup<Controls, Data>>;\n  let setControl: SetStoreFunction<IFormGroup<Controls, Data>>;\n\n  const [untilInit, initComplete] = propInitializer();\n\n  const [base, initializeBase] = createAbstractControlContainerBase(\n    () => [control, setControl],\n    untilInit,\n    initOptions\n  );\n\n  let rawValueMemo: Accessor<ControlsRawValue<Controls>>;\n  let valueMemo: Accessor<ControlsValue<Controls>>;\n\n  const storeConfig = mergeObj(base, {\n    [AbstractControlInterface]: true,\n    [AbstractControlContainerInterface]: true,\n    [FormGroupInterface]: true,\n\n    controls: initControls,\n\n    get rawValue() {\n      return rawValueMemo?.() ?? untilInit({});\n    },\n\n    get value() {\n      return valueMemo?.() ?? untilInit({});\n    },\n\n    setControl<N extends ControlsKey<Controls>>(\n      key: N,\n      newControl: Controls[N] | null\n    ) {\n      if (\n        newControl === null\n          ? !control.controls[key]\n          : isEqual(control.controls[key], newControl)\n      ) {\n        return;\n      }\n\n      setControl(\n        produce((state) => {\n          if (newControl === null) {\n            delete state.controls[key];\n          } else {\n            state.controls[key] = newControl;\n          }\n        })\n      );\n    },\n  } as IFormGroup<Controls, Data>);\n\n  [control, setControl] = createStore(storeConfig);\n\n  initializeBase();\n\n  const allControlEntriesMemo = createMemo(() =>\n    Object.entries(control.controls)\n  );\n\n  const enabledControlEntriesMemo = createMemo(() =>\n    allControlEntriesMemo().filter(([, c]) => !c.isDisabled)\n  );\n\n  rawValueMemo = createMemo(\n    () =>\n      Object.fromEntries(\n        allControlEntriesMemo().map(([k, c]) => [k, c.rawValue])\n      ) as ControlsRawValue<Controls>\n  );\n\n  valueMemo = createMemo(\n    () =>\n      Object.fromEntries(\n        enabledControlEntriesMemo().map(([k, c]) => [k, c.value])\n      ) as ControlsValue<Controls>\n  );\n\n  initComplete();\n\n  // Intentionally not using `batch()` since it appears to mess with\n  // initializing a control with errors\n  if (initOptions.disabled) control.markDisabled(initOptions.disabled);\n  if (initOptions.touched) control.markTouched(initOptions.touched);\n  if (initOptions.dirty) control.markDirty(initOptions.dirty);\n  if (initOptions.readonly) control.markReadonly(initOptions.readonly);\n  if (initOptions.submitted) control.markSubmitted(initOptions.submitted);\n  if (initOptions.required) control.markRequired(initOptions.required);\n  if (initOptions.pending) control.markPending(initOptions.pending);\n  if (initOptions.validators) control.setValidators(initOptions.validators);\n  if (initOptions.pending) control.markPending(initOptions.pending);\n  // this needs to be last to ensure that the errors aren't overwritten\n  if (initOptions.errors) control.patchErrors(initOptions.errors);\n\n  return control as unknown as IFormGroup<Controls, Data>;\n}\n","import {\n  AbstractControlInterface,\n  ControlId,\n  IAbstractControl,\n} from './abstract-control';\nimport { createAbstractControlContainerBase } from './abstract-control-container-base';\nimport {\n  ControlsValue,\n  ControlsRawValue,\n  ControlsKey,\n  IAbstractControlContainer,\n  AbstractControlContainerInterface,\n  isAbstractControlContainer,\n} from './abstract-control-container';\nimport {\n  IAbstractControlBaseOptions,\n  propInitializer,\n} from './abstract-control-base';\nimport { createStore, produce, SetStoreFunction, Store } from 'solid-js/store';\nimport { Accessor, batch, createMemo } from 'solid-js';\nimport { isEqual, mergeObj } from './util';\nimport type { PartialDeep } from 'type-fest';\n\nexport const FormArrayInterface = '@@FormArrayInterface_solidjs';\n\nexport interface IFormArrayOptions<\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> extends IAbstractControlBaseOptions<Data> {}\n\nexport interface IFormArray<\n  Controls extends ReadonlyArray<IAbstractControl> = ReadonlyArray<IAbstractControl>,\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> extends IAbstractControlContainer<Controls, Data> {\n  [FormArrayInterface]: true;\n  push(control: Controls[number]): void;\n  setControls(controls: Controls): void;\n  removeControl(\n    keyOrControl: ControlsKey<Controls> | Controls[ControlsKey<Controls>]\n  ): void;\n  patchValue(value: PartialDeep<ControlsRawValue<Controls>>): void;\n}\n\n/**\n * Returns true if the provided object implements\n * `IFormArray`\n */\nexport function isFormArray(object?: unknown): object is IFormArray {\n  return (\n    isAbstractControlContainer(object) &&\n    (object as any)?.[FormArrayInterface] === true\n  );\n}\n\nexport function createFormArray<\n  Controls extends ReadonlyArray<IAbstractControl> = ReadonlyArray<IAbstractControl>,\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n>(\n  controls?: Controls,\n  options?: IFormArrayOptions<Data>\n): IFormArray<Controls, Data>;\nexport function createFormArray<\n  Controls extends ReadonlyArray<IAbstractControl> = ReadonlyArray<IAbstractControl>,\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n>(\n  initControls = [] as unknown as Controls,\n  initOptions: IFormArrayOptions<Data> = {}\n): IFormArray<Controls, Data> {\n  let control: Store<IFormArray<Controls, Data>>;\n  let setControl: SetStoreFunction<IFormArray<Controls, Data>>;\n\n  const [untilInit, initComplete] = propInitializer();\n\n  const [base, initializeBase] = createAbstractControlContainerBase(\n    () => [control, setControl],\n    untilInit,\n    initOptions\n  );\n\n  let rawValueMemo: Accessor<ControlsRawValue<Controls>>;\n  let valueMemo: Accessor<ControlsValue<Controls>>;\n\n  const storeConfig = mergeObj(base, {\n    [AbstractControlInterface]: true,\n    [AbstractControlContainerInterface]: true,\n    [FormArrayInterface]: true,\n\n    controls: initControls,\n\n    get rawValue() {\n      return rawValueMemo?.() ?? untilInit({});\n    },\n\n    get value() {\n      return valueMemo?.() ?? untilInit({});\n    },\n\n    setControl<N extends ControlsKey<Controls>>(\n      key: N,\n      newControl: Controls[N] | null\n    ) {\n      if (\n        newControl === null\n          ? !control.controls[key]\n          : isEqual(control.controls[key], newControl)\n      ) {\n        return;\n      }\n\n      setControl(\n        produce((state) => {\n          if (newControl === null) {\n            (\n              state.controls as unknown as Array<\n                typeof state['controls'][number]\n              >\n            ).splice(key, 1);\n          } else {\n            state.controls[key] = newControl;\n          }\n        })\n      );\n    },\n\n    push(control: Controls[number]) {\n      this.setControl(this.controls.length, control);\n    },\n  } as IFormArray<Controls, Data>);\n\n  [control, setControl] = createStore(storeConfig);\n\n  initializeBase();\n\n  const enabledControlsMemo = createMemo(() =>\n    control.controls.filter((c) => !c.isDisabled)\n  );\n\n  rawValueMemo = createMemo(\n    () =>\n      (control as IFormArray<Controls, Data>).controls.map(\n        (c) => c.rawValue\n      ) as unknown as ControlsRawValue<Controls>\n  );\n\n  valueMemo = createMemo(\n    () =>\n      enabledControlsMemo().map(\n        (c) => c.value\n      ) as unknown as ControlsValue<Controls>\n  );\n\n  initComplete();\n\n  // Intentionally not using `batch()` since it appears to mess with\n  // initializing a control with errors\n  if (initOptions.disabled) control.markDisabled(initOptions.disabled);\n  if (initOptions.touched) control.markTouched(initOptions.touched);\n  if (initOptions.dirty) control.markDirty(initOptions.dirty);\n  if (initOptions.readonly) control.markReadonly(initOptions.readonly);\n  if (initOptions.submitted) control.markSubmitted(initOptions.submitted);\n  if (initOptions.required) control.markRequired(initOptions.required);\n  if (initOptions.pending) control.markPending(initOptions.pending);\n  if (initOptions.validators) control.setValidators(initOptions.validators);\n  if (initOptions.pending) control.markPending(initOptions.pending);\n  // this needs to be last to ensure that the errors aren't overwritten\n  if (initOptions.errors) control.patchErrors(initOptions.errors);\n\n  return control as unknown as IFormArray<Controls, Data>;\n}\n"],"names":["AbstractControlInterface","isAbstractControl","object","AbstractControlContainerInterface","isAbstractControlContainer","isEqual","a","b","_isEqual","mergeObj","Object","defineProperties","getOwnPropertyDescriptors","bindOwner","fn","owner","getOwner","Error","runWithOwner","DEFAULT_SOURCE","propInitializer","createSignal","initializationSignal","setInitializationSignal","value","composeValidators","validators","Array","isArray","length","control","reduce","prev","curr","errors","controlId","createAbstractControlBase","store","untilInit","initOptions","setControl","selfIsPendingMemo","selfErrorsMemo","statusMemo","validatorMemo","base","id","Symbol","data","self","isValid","isPending","isDisabled","isTouched","isDirty","isReadonly","isSubmitted","isRequired","errorsStore","Map","pendingStore","Set","validatorStore","status","validator","markDisabled","input","markReadonly","markRequired","markDirty","markTouched","markSubmitted","markPending","options","newPendingStore","source","has","add","produce","state","setErrors","existingStore","newErrorsStore","keys","set","patchErrors","newErrors","existingValue","get","_objectSpread","entries","k","err","filter","v","fromEntries","setValidators","newValidatorsStore","newValidator","setData","key","initializer","createMemo","size","from","values","p","c","e","createComputed","on","rawValue","FormControlInterface","isFormControl","createFormControl","initValue","initComplete","initializeBase","storeConfig","createStore","disabled","touched","dirty","readonly","submitted","required","pending","createAbstractControlContainerBase","initializeAbstractControl","sizeMemo","childIsValidMemo","childIsDisabledMemo","childIsReadonlyMemo","childIsRequiredMemo","childIsPendingMemo","childIsTouchedMemo","childIsDirtyMemo","childIsSubmittedMemo","childrenAreValidMemo","childrenAreDisabledMemo","childrenAreReadonlyMemo","childrenAreRequiredMemo","childrenArePendingMemo","childrenAreTouchedMemo","childrenAreDirtyMemo","childrenAreSubmittedMemo","errorsMemo","childrenErrorsMemo","containerBase","children","areDisabled","child","areReadonly","areSubmitted","areValid","areRequired","arePending","areTouched","areDirty","batch","controls","forEach","deep","setControls","removeControl","keyOrControl","childControl","setValue","valueEntries","val","patchValue","entryValue","allControlsMemo","nonDisabledControlsMemo","some","every","FormGroupInterface","isFormGroup","createFormGroup","initControls","rawValueMemo","valueMemo","newControl","allControlEntriesMemo","enabledControlEntriesMemo","map","FormArrayInterface","isFormArray","createFormArray","splice","enabledControlsMemo"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/core/index.module.js b/dist/core/index.module.js
index d1d9a7c717be9d2b0d16d0c29f302fdd16f3f4aa..a73fa1fc3737b94562cb1805765556020cf091d7 100644
--- a/dist/core/index.module.js
+++ b/dist/core/index.module.js
@@ -1,6 +1,6 @@
 import { produce, createStore } from 'solid-js/store';
 import { getOwner, runWithOwner, createSignal, createMemo, createComputed, on, batch } from 'solid-js';
-import _isEqual from 'fast-deep-equal/es6';
+import _isEqual from "deep-equal";
 
 function ownKeys(object, enumerableOnly) {
   var keys = Object.keys(object);
diff --git a/dist/core/index.module.js.map b/dist/core/index.module.js.map
index 99d675a2e8f5659dacfc2538864032fdc77fde1f..a2b26e79aa7c40a83ec7e89534c1f517888b5dee 100644
--- a/dist/core/index.module.js.map
+++ b/dist/core/index.module.js.map
@@ -1 +1 @@
-{"version":3,"file":"index.module.js","sources":["../../src/abstract-control.ts","../../src/abstract-control-container.ts","../../src/util.ts","../../src/abstract-control-base.ts","../../src/form-control.ts","../../src/abstract-control-container-base.ts","../../src/form-group.ts","../../src/form-array.ts"],"sourcesContent":["// *****************************\n// Misc Types\n// *****************************\n\nexport type ControlId = string | symbol;\n\nexport type ValidatorFn<T = any> = (rawValue: T) => ValidationErrors | null;\n\nexport interface ValidationErrors {\n  [key: string]: any;\n}\n\n// *****************************\n// AbstractControl interface\n// *****************************\n\nexport const AbstractControlInterface = '@@AbstractControlInterface_solidjs';\n\n/** Returns true if the provided object implements `IAbstractControl` */\nexport function isAbstractControl(\n  object?: unknown\n): object is IAbstractControl {\n  return (\n    typeof object === 'object' &&\n    (object as any)?.[AbstractControlInterface] === true\n  );\n}\n\nexport interface IAbstractControl<\n  RawValue = any,\n  Data extends Record<ControlId, any> = Record<ControlId, any>,\n  Value = RawValue\n> {\n  /**\n   * The ID is used to determine where StateChanges originated,\n   * and to ensure that a given AbstractControl only processes\n   * values one time.\n   */\n  readonly id: ControlId;\n\n  /**\n   * The data property can store arbitrary custom data. Use the\n   * `setData` method on `IAbstractControl` to update it.\n   *\n   * The `data` property is, itself, an object. You can set individual\n   * keys on the data property with `setData` but you cannot reset\n   * or clear the whole object. This is intentional. A library\n   * maintainer can store private data within the `data` property\n   * using a symbol without fear of the user accidently erasing it.\n   */\n  readonly data: Data;\n\n  /**\n   * The value of the IAbstractControl.\n   *\n   * In an IAbstractControlContainer,\n   * `value` and `rawValue` can be different, but in a standard\n   * `IAbstractControl` `value` is just an alias for `rawValue`.\n   * See the IAbstractControlContainer interface for possible differences\n   * between `value` and `rawValue`.\n   */\n  readonly value: Value;\n\n  /**\n   * The value of the IAbstractControl.\n   *\n   * In an IAbstractControlContainer,\n   * `value` and `rawValue` can be different, but in a standard\n   * `IAbstractControl` `value` is just an alias for `rawValue` and\n   * rawValue just contains the control's value.\n   * See the IAbstractControlContainer interface for possible differences\n   * between `value` and `rawValue`.\n   */\n  readonly rawValue: RawValue;\n\n  /**\n   * `true` if this control is disabled, false otherwise.\n   * This is an alias for `self.isDisabled`.\n   */\n  readonly isDisabled: boolean;\n\n  /**\n   * `true` if this control is touched, false otherwise.\n   * This is an alias for `self.isTouched`.\n   */\n  readonly isTouched: boolean;\n\n  /**\n   * `true` if this control is dirty, false otherwise.\n   * This is an alias for `self.isDirty`.\n   */\n  readonly isDirty: boolean;\n  /**\n   * `true` if this control is readonly, false otherwise.\n   * This is an alias for `self.isReadonly`.\n   */\n  readonly isReadonly: boolean;\n  /**\n   * `true` if this control is submitted, false otherwise.\n   * This is an alias for `self.isSubmitted`.\n   */\n  readonly isSubmitted: boolean;\n  /**\n   * `true` if this control is required, false otherwise.\n   * This is an alias for `self.isRequired`.\n   *\n   * Note that this property doesn't\n   * have any predefined meaning for IAbstractControls and it doesn't affect\n   * validation in any way. It is up to you to decide what meaning, if any,\n   * to give to this property and how to use it. For example, if you\n   * validated the control inside a `createEffect()`, you could choose to alter the\n   * validation based on whether the control was marked as `required` or\n   * not.\n   */\n  readonly isRequired: boolean;\n\n  /**\n   * Contains a `ValidationErrors` object if this control\n   * has any errors. Otherwise contains `null`.\n   *\n   * An alias for `self.errors`.\n   */\n  readonly errors: ValidationErrors | null;\n\n  /**\n   * A validator function that is run on rawValue changes and which\n   * generates errors associated with the source \"CONTROL_DEFAULT_SOURCE\".\n   */\n  readonly validator: ValidatorFn | null;\n\n  /**\n   * `true` if this control is pending, false otherwise.\n   * This is an alias for `self.isPending`.\n   */\n  readonly isPending: boolean;\n\n  /**\n   * Valid if `errors === null && !isPending`\n   *\n   * This is an alias for `self.valid`.\n   */\n  readonly isValid: boolean;\n\n  /**\n   * The `self` object on an abstract control contains\n   * properties reflecting the control's personal state. On an\n   * IAbstractControlContainer, the personal state can differ\n   * from the control's state. For example, an\n   * IAbstractControlContainer will register as disabled if\n   * the control itself has been marked as disabled OR if\n   * all of it's child controls are disabled.\n   *\n   * Marking the control container\n   * itself as disabled doesn't mark the container's children as\n   * disabled. On a standard IAbstractControl though,\n   * the \"self\" properties are the same as regular properties.\n   * I.e. `self.isInvalid` is the same as `isInvalid` on a\n   * standard IAbstractControl (actually, `isInvalid` is\n   * an alias for `self.isInvalid` on a standard control).\n   */\n  readonly self: {\n    /** `this.self.errors === null && !this.self.isPending` */\n    readonly isValid: boolean;\n\n    /** `true` if this control is disabled, false otherwise. */\n    readonly isDisabled: boolean;\n\n    /** `true` if this control is touched, false otherwise. */\n    readonly isTouched: boolean;\n\n    /**\n     * `true` if this control is dirty, false otherwise.\n     *\n     * Dirty can be thought of as, \"Has the value changed?\"\n     * Though the isDirty property must be manually set by\n     * the user (using `markDirty()`) and is not automatically\n     * updated.\n     */\n    readonly isDirty: boolean;\n    /**\n     * `true` if this control is readonly, false otherwise.\n     *\n     * This property does not have any predefined meeting for\n     * an IAbstractControl. You can decide if you want to give\n     * it meaning by, for example, using this value to set\n     * an input's readonly status (e.g.\n     * `<input readonly={control.isReadonly} />`)\n     */\n    readonly isReadonly: boolean;\n\n    /** `true` if this control is submitted, false otherwise. */\n    readonly isSubmitted: boolean;\n\n    /**\n     * `true` if this control is required, false otherwise.\n     *\n     * Note that this property doesn't\n     * have any predefined meaning for IAbstractControls and it doesn't affect\n     * validation in any way. It is up to you to decide what meaning, if any,\n     * to give to this property and how to use it. For example, if you\n     * validated the control inside a `createEffect()` you could alter the\n     * validation based on whether the control was marked as `required` or\n     * not.\n     */\n    readonly isRequired: boolean;\n\n    /** `true` if this control is pending, false otherwise. */\n    readonly isPending: boolean;\n\n    /**\n     * Contains a `ValidationErrors` object if this control\n     * has any errors. Otherwise contains `null`.\n     */\n    readonly errors: ValidationErrors | null;\n\n    /**\n     * *More advanced-ish*\n     *\n     * Contains a map of ControlId values and ValidationErrors.\n     * The errorsStore allows partitioning errors so that\n     * they can be associated with different sources and so\n     * that one source does not overwrite another source.\n     *\n     * The `self.errors` property gets its errors from the errorsStore.\n     */\n    readonly errorsStore: ReadonlyMap<ControlId, ValidationErrors>;\n\n    /**\n     * More advanced-ish*\n     *\n     * A set of ControlIds. `self.isPending` is true so long\n     * as `pendingStore.size > 0`. Because this is a set, you\n     * can track multiple pending \"things\" at once. This\n     * control will register as pending until all of the \"things\"\n     * have resolved. Use the `markPending()` method with\n     * the `source` option to update the pendingStore.\n     */\n    readonly pendingStore: ReadonlySet<ControlId>;\n\n    /**\n     * More advanced-ish*\n     *\n     * A map of ControlIds and ValidatorFns. The `validator`\n     * property is composed of all the validator functions in the\n     * `validatorStore`. The validatorStore allows you to change\n     * individual validator functions on the control without\n     * affecting other validator functions on the control.\n     *\n     * When you use the `setValidators` method, you are updating\n     * the validatorStore.\n     */\n    readonly validatorStore: ReadonlyMap<ControlId, ValidatorFn>;\n  };\n\n  /**\n   * If this control is disabled, the status is `\"DISABLED\"`,\n   * else if this control is pending, the status is `\"PENDING\"`,\n   * else if this control has any errors, the status is `\"INVALID\"`,\n   * else the status is `\"VALID\"`.\n   */\n  readonly status: 'DISABLED' | 'PENDING' | 'INVALID' | 'VALID';\n\n  [AbstractControlInterface]: true;\n\n  /** set the control's value  */\n  setValue(value: RawValue): void;\n\n  /**\n   * If provided a `ValidationErrors` object or `null`, replaces `self.errors`.\n   * Optionally, provide a source ID and the change will be partitioned\n   * assocaited with the source ID. The default source ID is\n   * \"CONTROL_DEFAULT_SOURCE\".\n   *\n   * If you provide a `Map` object containing `ValidationErrors` keyed to source IDs,\n   * that will replace the `self.errorsStore` associated with this control.\n   */\n  setErrors(\n    value: ValidationErrors | null | ReadonlyMap<ControlId, ValidationErrors>,\n    options?: { source?: ControlId }\n  ): void;\n\n  /**\n   * If you provide a `ValidationErrors` object, that object is merged with the\n   * existing errors associated with the source ID. If the error object has\n   * keys equal to `null`, errors associated with those keys are deleted\n   * from the errors object.\n   *\n   * If you provide a `Map` object containing `ValidationErrors` keyed to source IDs,\n   * that object is merged with the existing `errorsStore`.\n   */\n  patchErrors(\n    value: ValidationErrors | ReadonlyMap<ControlId, ValidationErrors>,\n    options?: { source?: ControlId }\n  ): void;\n\n  /** sets `self.isTouched` */\n  markTouched(value: boolean): void;\n\n  /** sets `self.isDirty` */\n  markDirty(value: boolean): void;\n\n  /** sets `self.isReadonly` */\n  markReadonly(value: boolean): void;\n\n  /**\n   * Sets `self.isRequired`.\n   *\n   * Note that this property doesn't\n   * have any predefined meaning for IAbstractControls and it doesn't affect\n   * validation in any way. It is up to you to decide what meaning, if any,\n   * to give to this property and how to use it. For example, if you\n   * validated the control inside a `createEffect()` you could alter the\n   * validation based on whether the control was marked as `required` or\n   * not.\n   */\n  markRequired(value: boolean): void;\n\n  /**\n   * Set `self.isDisabled`.\n   *\n   * Note that `self.isDisabled`` affect's the control's `status`\n   * property. Additionally, `IAbstractControlContainer's` ignore\n   * disabled children in many cases. For example, the `value` of a\n   * control container is equal to the value of it's _enabled_ children\n   * (if you want to see the value including disabled children, use\n   * `rawValue`).\n   */\n  markDisabled(value: boolean): void;\n\n  /** sets `self.isSubmitted` */\n  markSubmitted(value: boolean): void;\n\n  /** sets `self.pendingStore` and `self.isPending` */\n  markPending(\n    value: boolean | ReadonlySet<ControlId>,\n    options?: { source?: ControlId }\n  ): void;\n\n  /** sets `validator` and `self.validatorStore` */\n  setValidators(\n    value:\n      | ValidatorFn\n      | ValidatorFn[]\n      | ReadonlyMap<ControlId, ValidatorFn>\n      | null,\n    options?: { source?: ControlId }\n  ): void;\n\n  /**\n   * The data property can store arbitrary custom data. Use the\n   * `setData` method on `IAbstractControl` to update it.\n   *\n   * The `data` property is, itself, an object. You can set individual\n   * keys on the data property with `setData` but you cannot reset\n   * or clear the whole object. This is intentional. A library\n   * maintainer can store private data within the `data` property\n   * using a symbol without fear of the user accidently erasing it.\n   */\n  setData<K extends keyof Data>(key: K, data: Data[K]): void;\n}\n","import {\n  ControlId,\n  isAbstractControl,\n  ValidationErrors,\n} from './abstract-control';\nimport { IAbstractControl } from './abstract-control';\n\n// UTILITY TYPES\n\ntype PickUndefinedKeys<T> = {\n  [K in keyof T]: undefined extends T[K] ? K : never;\n}[keyof T];\n\ntype PickRequiredKeys<T> = {\n  [K in keyof T]: undefined extends T[K] ? never : K;\n}[keyof T];\n\ntype ObjectControlsOptionalRawValue<\n  T extends { [key: string]: IAbstractControl | undefined }\n> = {\n  [P in Exclude<PickUndefinedKeys<T>, undefined>]?: NonNullable<\n    T[P]\n  >['rawValue'];\n};\n\ntype ObjectControlsRequiredRawValue<\n  T extends { [key: string]: IAbstractControl | undefined }\n> = {\n  [P in Exclude<PickRequiredKeys<T>, undefined>]: NonNullable<T[P]>['rawValue'];\n};\n\ntype ArrayControlsRawValue<T extends ReadonlyArray<IAbstractControl>> =\n  T extends ReadonlyArray<infer C>\n    ? C extends IAbstractControl\n      ? ReadonlyArray<C['rawValue']>\n      : never\n    : never;\n\ntype ObjectControlsOptionalValue<\n  T extends { [key: string]: IAbstractControl | undefined }\n> = {\n  [P in Exclude<PickUndefinedKeys<T>, undefined>]?: NonNullable<T[P]>['value'];\n};\n\ntype ObjectControlsRequiredValue<\n  T extends { [key: string]: IAbstractControl | undefined }\n> = {\n  [P in Exclude<PickRequiredKeys<T>, undefined>]: NonNullable<T[P]>['value'];\n};\n\ntype ArrayControlsValue<T extends ReadonlyArray<IAbstractControl>> =\n  T extends ReadonlyArray<infer C>\n    ? C extends IAbstractControl\n      ? ReadonlyArray<C['value']>\n      : never\n    : never;\n\n// END UTILITY TYPES\n\nexport type GenericControlsObject =\n  | {\n      readonly [key: string]: IAbstractControl;\n    }\n  | ReadonlyArray<IAbstractControl>;\n\n// need to add the `keyof ControlsRawValue<Controls>` as well as\n// `keyof ControlsValue<Controls>` as well as the `keyof Controls` etc\n// because typescript doesn't realize that all three are the same keys\n// and without all three, then ControlsKey can't be used to index all three\nexport type ControlsKey<Controls extends GenericControlsObject> =\n  keyof ControlsRawValue<Controls> &\n    keyof ControlsValue<Controls> &\n    (Controls extends ReadonlyArray<any>\n      ? keyof Controls & number\n      : Controls extends object\n      ? // the `& string` is needed or else\n        // ControlsKey<{[key: string]: AbstractControl}> is type string | number\n        keyof Controls & string\n      : any);\n\nexport type ControlsRawValue<Controls extends GenericControlsObject> =\n  Controls extends ReadonlyArray<IAbstractControl>\n    ? ArrayControlsRawValue<Controls>\n    : Controls extends { readonly [key: string]: IAbstractControl | undefined }\n    ? ObjectControlsRequiredRawValue<Controls> &\n        ObjectControlsOptionalRawValue<Controls>\n    : never;\n\nexport type ControlsValue<Controls extends GenericControlsObject> =\n  Controls extends ReadonlyArray<IAbstractControl>\n    ? ArrayControlsValue<Controls>\n    : Controls extends { readonly [key: string]: IAbstractControl | undefined }\n    ? Partial<\n        ObjectControlsRequiredValue<Controls> &\n          ObjectControlsOptionalValue<Controls>\n      >\n    : never;\n\nexport type ContainerControls<C> = C extends IAbstractControlContainer<\n  infer Controls\n>\n  ? Controls\n  : unknown;\n\nexport const AbstractControlContainerInterface =\n  '@@AbstractControlContainerInterface_solidjs';\n\n/**\n * Returns true if the provided object implements\n * `IAbstractControlContainer`\n */\nexport function isAbstractControlContainer(\n  object?: unknown\n): object is IAbstractControlContainer {\n  return (\n    isAbstractControl(object) &&\n    (object as any)[AbstractControlContainerInterface]\n  );\n}\n\nexport interface IAbstractControlContainer<\n  Controls extends GenericControlsObject = any,\n  Data = any\n> extends IAbstractControl<\n    ControlsRawValue<Controls>,\n    Data,\n    ControlsValue<Controls>\n  > {\n  /** Child controls associated with this container */\n  readonly controls: Controls;\n\n  /** The number of controls associated with this container */\n  readonly size: number;\n\n  /** Only returns values for enabled child controls. */\n  readonly value: ControlsValue<Controls>;\n\n  /**\n   * Returns values for both enabled and disabled child controls.\n   */\n  readonly rawValue: ControlsRawValue<Controls>;\n\n  /** Will return true if `this.self.isValid` and `this.children.areValid` */\n  readonly isValid: boolean;\n\n  /** Will return true if `this.self.isDisabled` or `this.children.areDisabled` */\n  readonly isDisabled: boolean;\n\n  /** Will return true if `this.self.isReadonly` or `this.children.areReadonly` */\n  readonly isReadonly: boolean;\n\n  /** Will return true if `this.self.isRequired` or `this.child.isRequired` */\n  readonly isRequired: boolean;\n\n  /** Will return true if `this.self.isPending` or `this.child.isPending` */\n  readonly isPending: boolean;\n\n  /** Will return true if `this.self.isTouched` or `this.child.isTouched` */\n  readonly isTouched: boolean;\n\n  /** Will return true if `this.self.isDirty` or `this.child.isDirty` */\n  readonly isDirty: boolean;\n\n  /** Will return true if `this.self.isSubmitted` or `this.children.areSubmitted` */\n  readonly isSubmitted: boolean;\n\n  /** Contains `{ ...this.children.errors, ...this.self.errors }` or `null` if there are none */\n  readonly errors: ValidationErrors | null;\n\n  readonly child: {\n    /** Will return true if *any* `enabled` direct child control is `valid` */\n    readonly isValid: boolean;\n    /** Will return true if *any* direct child control is `disabled` */\n    readonly isDisabled: boolean;\n    /** Will return true if *any* `enabled` direct child control is `readonly` */\n    readonly isReadonly: boolean;\n    /** Will return true if *any* `enabled` direct child control is `required` */\n    readonly isRequired: boolean;\n    /** Will return true if *any* `enabled` direct child control is `pending` */\n    readonly isPending: boolean;\n    /** Will return true if *any* `enabled` direct child control is `touched` */\n    readonly isTouched: boolean;\n    /** Will return true if *any* `enabled` direct child control is `dirty` */\n    readonly isDirty: boolean;\n    /** Will return true if *any* `enabled` direct child control is `submitted` */\n    readonly isSubmitted: boolean;\n  };\n\n  readonly children: {\n    /** Will return true if *all* `enabled` direct child control's are `valid` */\n    readonly areValid: boolean;\n    /** Will return true if *all* direct child control's are `disabled` */\n    readonly areDisabled: boolean;\n    /** Will return true if *all* `enabled` direct child control's are `readonly` */\n    readonly areReadonly: boolean;\n    /** Will return true if *all* `enabled` direct child control's are `required` */\n    readonly areRequired: boolean;\n    /** Will return true if *all* `enabled` direct child control's are `pending` */\n    readonly arePending: boolean;\n    /** Will return true if *all* `enabled` direct child control's are `touched` */\n    readonly areTouched: boolean;\n    /** Will return true if *all* `enabled` direct child control's are `dirty` */\n    readonly areDirty: boolean;\n    /** Will return true if *all* `enabled` direct child control's are `submitted` */\n    readonly areSubmitted: boolean;\n    /** Contains *all* `enabled` child control errors or `null` if there are none */\n    readonly errors: ValidationErrors | null;\n\n    /**\n     * Mark all direct children as disabled. Use the `deep: true`\n     * option to instead mark all direct and indirect children\n     * as disabled.\n     */\n    markDisabled(value: boolean, options?: { deep?: boolean }): void;\n\n    /**\n     * Mark all direct children as touched. Use the `deep: true`\n     * option to instead mark all direct and indirect children\n     * as touched.\n     */\n    markTouched(value: boolean, options?: { deep?: boolean }): void;\n\n    /**\n     * Mark all direct children as dirty. Use the `deep: true`\n     * option to instead mark all direct and indirect children\n     * as dirty.\n     */\n    markDirty(value: boolean, options?: { deep?: boolean }): void;\n\n    /**\n     * Mark all direct children as readonly. Use the `deep: true`\n     * option to instead mark all direct and indirect children\n     * as readonly.\n     */\n    markReadonly(value: boolean, options?: { deep?: boolean }): void;\n\n    /**\n     * Mark all direct children as required. Use the `deep: true`\n     * option to instead mark all direct and indirect children\n     * as required.\n     */\n    markRequired(value: boolean, options?: { deep?: boolean }): void;\n\n    /**\n     * Mark all direct children as submitted. Use the `deep: true`\n     * option to instead mark all direct and indirect children\n     * as submitted.\n     */\n    markSubmitted(value: boolean, options?: { deep?: boolean }): void;\n\n    /**\n     * Mark all direct children as pending. Use the `deep: true`\n     * option to instead mark all direct and indirect children\n     * as pending.\n     */\n    markPending(\n      value: boolean,\n      options?: { source?: ControlId; deep?: boolean }\n    ): void;\n  };\n\n  [AbstractControlContainerInterface]: true;\n\n  /**\n   * Apply a partial update to the values of some children but\n   * not all.\n   */\n  patchValue(value: unknown): void;\n\n  /** sets the `controls` property */\n  setControls(controls: Controls): void;\n\n  /** stores the provided control in `controls[key]` */\n  setControl(key: unknown, control: unknown): void;\n\n  /**\n   * If provided a control value, removes the given control from\n   * `controls`. If provided a control key value, removes the\n   * control associated with the given key from `controls`.\n   */\n  removeControl(keyOrControl: unknown): void;\n}\n","import _isEqual from 'fast-deep-equal/es6';\nimport { getOwner, runWithOwner } from 'solid-js';\nimport type { Merge } from 'type-fest';\n\nexport function isEqual<T>(a: T, b: any): b is T {\n  return _isEqual(a, b);\n}\n\nexport function mergeObj<A, B>(a: A, b: Merge<Partial<A>, B>): Merge<A, B> {\n  return Object.defineProperties(\n    a,\n    Object.getOwnPropertyDescriptors(b)\n  ) as unknown as Merge<A, B>;\n}\n\n/**\n * Helper to bind the owner of the current context to the\n * supplied function.\n *\n * Implementation is very simple:\n * ```ts\n * import { getOwner, runWithOwner } from 'solid-js';\n *\n * export function bindOwner<T>(fn: () => T): () => T {\n *   const owner = getOwner();\n *\n *   if (!owner) {\n *     throw new Error('No solidjs owner in current context');\n *   }\n *\n *   return () => runWithOwner(owner, fn);\n * }\n * ```\n */\nexport function bindOwner<T>(fn: () => T): () => T {\n  const owner = getOwner();\n\n  if (!owner) {\n    throw new Error('No solidjs owner in current context');\n  }\n\n  return () => runWithOwner(owner, fn);\n}\n","import type {\n  ValidatorFn,\n  ValidationErrors,\n  ControlId,\n  AbstractControlInterface,\n} from './abstract-control';\nimport { IAbstractControl } from './abstract-control';\nimport { produce, SetStoreFunction, Store } from 'solid-js/store';\nimport {\n  Accessor,\n  createComputed,\n  createMemo,\n  createSignal,\n  on,\n} from 'solid-js';\nimport { isEqual } from './util';\n\nexport const DEFAULT_SOURCE = 'CONTROL_DEFAULT_SOURCE';\n\nexport interface IAbstractControlBaseOptions<\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> {\n  id?: ControlId;\n  data?: Data;\n  disabled?: boolean;\n  touched?: boolean;\n  dirty?: boolean;\n  readonly?: boolean;\n  required?: boolean;\n  submitted?: boolean;\n  errors?: null | ValidationErrors | ReadonlyMap<ControlId, ValidationErrors>;\n  validators?:\n    | null\n    | ValidatorFn\n    | ValidatorFn[]\n    | ReadonlyMap<ControlId, ValidatorFn>;\n  pending?: boolean | ReadonlySet<ControlId>;\n}\n\nexport function propInitializer(): [\n  propInitializing: <T>(value: T) => T,\n  initComplete: () => void\n] {\n  const [initializationSignal, setInitializationSignal] = createSignal<\n    null | false\n  >(null);\n\n  return [\n    <T>(value: T) => initializationSignal() || value,\n    () => setInitializationSignal(false),\n  ];\n}\n\nexport function composeValidators(\n  validators: undefined | null | ValidatorFn | ValidatorFn[]\n): null | ValidatorFn {\n  if (!validators || (Array.isArray(validators) && validators.length === 0)) {\n    return null;\n  }\n\n  if (Array.isArray(validators)) {\n    return (control) =>\n      validators.reduce((prev: ValidationErrors | null, curr: ValidatorFn) => {\n        const errors = curr(control);\n        return errors ? { ...prev, ...errors } : prev;\n      }, null);\n  }\n\n  return validators;\n}\n\nexport type IAbstractControlBase<\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> = Omit<\n  IAbstractControl<unknown, Data, unknown>,\n  'value' | 'rawValue' | 'setValue' | typeof AbstractControlInterface\n>;\n\nlet controlId = 0;\n\nexport function createAbstractControlBase<\n  RawValue,\n  Data extends Record<ControlId, any> = Record<ControlId, any>,\n  Value = RawValue\n>(\n  store: Accessor<\n    [\n      Store<IAbstractControl<RawValue, Data, Value>>,\n      SetStoreFunction<IAbstractControl<RawValue, Data, Value>>\n    ]\n  >,\n  untilInit: <T>(value: T) => T,\n  initOptions: Pick<IAbstractControlBaseOptions<Data>, 'id' | 'data'> = {}\n): [base: IAbstractControlBase<Data>, initializer: () => void] {\n  let control: Store<IAbstractControl<RawValue, Data, Value>>;\n  let setControl: SetStoreFunction<IAbstractControl<RawValue, Data, Value>>;\n\n  let selfIsPendingMemo: Accessor<IAbstractControl['self']['isPending']>;\n  let selfErrorsMemo: Accessor<ValidationErrors | null>;\n  let statusMemo: Accessor<IAbstractControl['status']>;\n  let validatorMemo: Accessor<IAbstractControl['validator']>;\n\n  const base: IAbstractControlBase<Data> = {\n    id: initOptions.id || Symbol(`AbstractControl-${controlId++}`),\n\n    data: { ...(initOptions.data as Data) },\n\n    self: {\n      get isValid() {\n        // here \"this\" is self\n        return this.errors === null && !this.isPending;\n      },\n      isDisabled: false,\n      isTouched: false,\n      isDirty: false,\n      isReadonly: false,\n      isSubmitted: false,\n      isRequired: false,\n      get isPending() {\n        return selfIsPendingMemo?.() ?? untilInit(false);\n      },\n      get errors() {\n        return selfErrorsMemo?.() ?? untilInit(null);\n      },\n      errorsStore: new Map(),\n      pendingStore: new Set(),\n      validatorStore: new Map(),\n    },\n\n    get isDisabled() {\n      return this.self.isDisabled;\n    },\n\n    get isTouched() {\n      return this.self.isTouched;\n    },\n\n    get isDirty() {\n      return this.self.isDirty;\n    },\n\n    get isReadonly() {\n      return this.self.isReadonly;\n    },\n\n    get isSubmitted() {\n      return this.self.isSubmitted;\n    },\n\n    get isRequired() {\n      return this.self.isRequired;\n    },\n\n    get errors() {\n      return this.self.errors;\n    },\n\n    get isPending() {\n      return this.self.isPending;\n    },\n\n    get isValid() {\n      return this.self.isValid;\n    },\n\n    get status() {\n      return statusMemo?.() ?? untilInit('VALID');\n    },\n\n    get validator() {\n      return validatorMemo?.() ?? untilInit(null);\n    },\n\n    markDisabled(input) {\n      if (isEqual(this.self.isDisabled, input)) return;\n      setControl('self', 'isDisabled', input);\n    },\n\n    markReadonly(input) {\n      if (isEqual(this.self.isReadonly, input)) return;\n      setControl('self', 'isReadonly', input);\n    },\n\n    markRequired(input) {\n      if (isEqual(this.self.isRequired, input)) return;\n      setControl('self', 'isRequired', input);\n    },\n\n    markDirty(input) {\n      if (isEqual(this.self.isDirty, input)) return;\n      setControl('self', 'isDirty', input);\n    },\n\n    markTouched(input) {\n      if (isEqual(this.self.isTouched, input)) return;\n      setControl('self', 'isTouched', input);\n    },\n\n    markSubmitted(input) {\n      if (isEqual(this.self.isSubmitted, input)) return;\n      setControl('self', 'isSubmitted', input);\n    },\n\n    markPending(input, options) {\n      let newPendingStore: Set<ControlId>;\n\n      if (typeof input === 'boolean') {\n        const source = options?.source || DEFAULT_SOURCE;\n\n        if (this.self.pendingStore.has(source) === input) return;\n\n        newPendingStore = new Set(this.self.pendingStore);\n\n        if (input) {\n          newPendingStore.add(source);\n        } else {\n          newPendingStore.delete(source);\n        }\n      } else {\n        if (this.self.pendingStore === input) return;\n\n        newPendingStore = new Set(input);\n      }\n\n      if (isEqual(this.self.pendingStore, newPendingStore)) return;\n\n      // We're using `produce()` here because using the standard solid Store\n      // nested setter has some bugs (i.e.\n      // `setControl('self', 'pendingStore', newPendingStore)`). I think the\n      // bugs are isolated to object values, so, at the moment, I'm only using\n      // produce where the value is an object.\n      setControl(\n        produce((state) => {\n          (state.self.pendingStore as Set<ControlId>) = newPendingStore;\n        })\n      );\n    },\n\n    setErrors(input, options) {\n      const source = options?.source || DEFAULT_SOURCE;\n\n      const existingStore = this.self.errorsStore;\n\n      let newErrorsStore: Map<ControlId, ValidationErrors>;\n\n      if (input instanceof Map) {\n        newErrorsStore = input;\n      } else if (input === null || Object.keys(input).length === 0) {\n        newErrorsStore = new Map(existingStore);\n        newErrorsStore.delete(source);\n      } else {\n        newErrorsStore = new Map(existingStore).set(source, input);\n      }\n\n      if (isEqual(this.self.errorsStore, newErrorsStore)) return;\n\n      // We're using `produce()` here because using the standard solid Store\n      // nested setter has some bugs (i.e.\n      // `setControl('self', 'pendingStore', newPendingStore)`). I think the\n      // bugs are isolated to object values, so, at the moment, I'm only using\n      // produce where the value is an object.\n      setControl(\n        produce((state) => {\n          (state.self.errorsStore as Map<ControlId, ValidationErrors>) =\n            newErrorsStore;\n        })\n      );\n    },\n\n    patchErrors(input, options) {\n      const existingStore = this.self.errorsStore as Map<\n        ControlId,\n        ValidationErrors\n      >;\n\n      if (input instanceof Map) {\n        // We're using `produce()` here because using the standard solid Store\n        // nested setter has some bugs (i.e.\n        // `setControl('self', 'pendingStore', newPendingStore)`). I think the\n        // bugs are isolated to object values, so, at the moment, I'm only using\n        // produce where the value is an object.\n        setControl(\n          produce((state) => {\n            (state.self.errorsStore as Map<ControlId, ValidationErrors>) =\n              new Map([...existingStore, ...input]);\n          })\n        );\n      } else {\n        if (Object.keys(input).length === 0) return;\n\n        const source = options?.source || DEFAULT_SOURCE;\n\n        let newErrors: ValidationErrors = input;\n\n        let existingValue = existingStore.get(source);\n\n        if (existingValue) {\n          existingValue = { ...existingValue };\n\n          for (const [k, err] of Object.entries(newErrors)) {\n            if (err === null) {\n              delete existingValue![k];\n            } else {\n              existingValue![k] = err;\n            }\n          }\n\n          newErrors = existingValue;\n        } else {\n          const entries = Object.entries(newErrors).filter(\n            ([, v]) => v !== null\n          );\n\n          if (entries.length === 0) return;\n\n          newErrors = Object.fromEntries(entries);\n        }\n\n        const newErrorsStore = new Map(existingStore);\n\n        if (Object.keys(newErrors).length === 0) {\n          newErrorsStore.delete(source);\n        } else {\n          newErrorsStore.set(source, newErrors);\n        }\n\n        if (isEqual(this.self.errorsStore, newErrorsStore)) return;\n\n        // We're using `produce()` here because using the standard solid Store\n        // nested setter has some bugs (i.e.\n        // `setControl('self', 'pendingStore', newPendingStore)`). I think the\n        // bugs are isolated to object values, so, at the moment, I'm only using\n        // produce where the value is an object.\n        setControl(\n          produce((state) => {\n            (state.self.errorsStore as Map<ControlId, ValidationErrors>) =\n              newErrorsStore;\n          })\n        );\n      }\n    },\n\n    setValidators(input, options) {\n      const source = options?.source || DEFAULT_SOURCE;\n\n      let newValidatorsStore: Map<ControlId, ValidatorFn>;\n\n      if (input instanceof Map) {\n        newValidatorsStore = new Map(input);\n      } else {\n        newValidatorsStore = new Map(\n          this.self.validatorStore as Map<ControlId, ValidatorFn>\n        );\n\n        const newValidator = composeValidators(\n          input as Exclude<typeof input, ReadonlyMap<any, any>>\n        );\n\n        if (newValidator) {\n          newValidatorsStore.set(source, newValidator);\n        } else {\n          newValidatorsStore.delete(source);\n        }\n      }\n\n      if (isEqual(this.self.validatorStore, newValidatorsStore)) return;\n\n      // We're using `produce()` here because using the standard solid Store\n      // nested setter has some bugs (i.e.\n      // `setControl('self', 'pendingStore', newPendingStore)`). I think the\n      // bugs are isolated to object values, so, at the moment, I'm only using\n      // produce where the value is an object.\n      setControl(\n        produce((state) => {\n          (state.self.validatorStore as Map<ControlId, ValidatorFn<any>>) =\n            newValidatorsStore;\n        })\n      );\n    },\n\n    setData(key, input) {\n      if (isEqual(this.data[key], input)) return;\n      // We're using `produce()` here because using the standard solid Store\n      // nested setter has some bugs (i.e.\n      // `setControl('self', 'pendingStore', newPendingStore)`). I think the\n      // bugs are isolated to object values, so, at the moment, I'm only using\n      // produce where the value is an object.\n      setControl(\n        produce((state) => {\n          state.data[key] = input;\n        })\n      );\n    },\n  };\n\n  const initializer = () => {\n    [control, setControl] = store();\n\n    selfIsPendingMemo = createMemo(() => control.self.pendingStore.size > 0);\n\n    selfErrorsMemo = createMemo(() => {\n      return control.self.errorsStore.size === 0\n        ? null\n        : Array.from(\n            control.self.errorsStore.values()\n          ).reduce<ValidationErrors>(\n            (p, errors) => ({\n              ...p,\n              ...errors,\n            }),\n            {}\n          );\n    });\n\n    statusMemo = createMemo(() => {\n      return control.isDisabled\n        ? 'DISABLED'\n        : control.isPending\n        ? 'PENDING'\n        : control.isValid\n        ? 'VALID'\n        : 'INVALID';\n    });\n\n    validatorMemo = createMemo(() => {\n      if (control.self.validatorStore.size === 0) return null;\n\n      const validators = Array.from(control.self.validatorStore.values());\n\n      return (c) => {\n        const e = validators.reduce<ValidationErrors>((err, v) => {\n          return { ...err, ...v(c) };\n        }, {});\n\n        return Object.keys(e).length === 0 ? null : e;\n      };\n    });\n\n    // Intentionally not using `createRenderEffect()` since it appears to\n    // mess with initializing a control with errors (i.e. it clears the errors\n    // after the control is initialized)\n    createComputed(\n      on(\n        () => control.validator?.(control.rawValue) ?? null,\n        (errors) => {\n          if (control.self.errorsStore.get(DEFAULT_SOURCE) === errors) return;\n\n          const newErrorsStore = new Map(\n            control.self.errorsStore as Map<ControlId, ValidationErrors>\n          );\n\n          if (errors) {\n            newErrorsStore.set(DEFAULT_SOURCE, errors);\n          } else {\n            newErrorsStore.delete(DEFAULT_SOURCE);\n          }\n\n          if (isEqual(control.self.errorsStore, newErrorsStore)) return;\n\n          // We're using `produce()` here because using the standard solid Store\n          // nested setter has some bugs (i.e.\n          // `setControl('self', 'pendingStore', newPendingStore)`). I think the\n          // bugs are isolated to object values, so, at the moment, I'm only using\n          // produce where the value is an object.\n          setControl(\n            produce((state) => {\n              (state.self.errorsStore as Map<ControlId, ValidationErrors>) =\n                newErrorsStore;\n            })\n          );\n        }\n      )\n    );\n  };\n\n  return [base, initializer];\n}\n","import { createStore, produce, SetStoreFunction, Store } from 'solid-js/store';\nimport {\n  IAbstractControl,\n  ControlId,\n  AbstractControlInterface,\n  isAbstractControl,\n} from './abstract-control';\nimport {\n  IAbstractControlBaseOptions,\n  createAbstractControlBase,\n  propInitializer,\n} from './abstract-control-base';\nimport { isEqual, mergeObj } from './util';\n\nexport const FormControlInterface = '@@FormControlInterface_solidjs';\n\nexport interface IFormControlOptions<\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> extends IAbstractControlBaseOptions<Data> {}\n\nexport interface IFormControl<\n  Value = any,\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> extends IAbstractControl<Value, Data, Value> {\n  [FormControlInterface]: true;\n}\n\n/**\n * Returns true if the provided object implements\n * `IFormControl`\n */\nexport function isFormControl(object?: unknown): object is IFormControl {\n  return (\n    isAbstractControl(object) &&\n    (object as any)?.[FormControlInterface] === true\n  );\n}\n\nexport function createFormControl<\n  Value,\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n>(\n  value?: Value,\n  options?: IFormControlOptions<Data>\n): IFormControl<Value, Data>;\nexport function createFormControl<\n  Value,\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n>(\n  initValue?: Value,\n  initOptions: IFormControlOptions<Data> = {}\n): IFormControl<Value, Data> {\n  let control: Store<IFormControl<Value, Data>>;\n  let setControl: SetStoreFunction<IFormControl<Value, Data>>;\n\n  const [untilInit, initComplete] = propInitializer();\n\n  const [base, initializeBase] = createAbstractControlBase<Value, Data, Value>(\n    () => [control, setControl],\n    untilInit,\n    initOptions\n  );\n\n  const storeConfig = mergeObj(base, {\n    [AbstractControlInterface]: true,\n    [FormControlInterface]: true,\n\n    rawValue: initValue as Value,\n\n    get value() {\n      return this.rawValue;\n    },\n\n    setValue(value) {\n      if (isEqual(this.value, value)) return;\n\n      // We're using `produce()` here because using the standard solid Store\n      // nested setter has some bugs (i.e.\n      // `setControl('self', 'pendingStore', newPendingStore)`). I think the\n      // bugs are isolated to object values, so, at the moment, I'm only using\n      // produce where the value could be an object.\n      setControl(\n        produce((state) => {\n          (state.rawValue as Value) = value;\n        })\n      );\n    },\n  } as IFormControl<Value, Data>);\n\n  [control, setControl] = createStore<IFormControl<Value, Data>>(storeConfig);\n\n  initializeBase();\n  initComplete();\n\n  // Intentionally not using `batch()` since it appears to mess with\n  // initializing a control with errors\n  if (initOptions.disabled) control.markDisabled(initOptions.disabled);\n  if (initOptions.touched) control.markTouched(initOptions.touched);\n  if (initOptions.dirty) control.markDirty(initOptions.dirty);\n  if (initOptions.readonly) control.markReadonly(initOptions.readonly);\n  if (initOptions.submitted) control.markSubmitted(initOptions.submitted);\n  if (initOptions.required) control.markRequired(initOptions.required);\n  if (initOptions.pending) control.markPending(initOptions.pending);\n  if (initOptions.validators) control.setValidators(initOptions.validators);\n  if (initOptions.pending) control.markPending(initOptions.pending);\n  // this needs to be last to ensure that the errors aren't overwritten\n  if (initOptions.errors) control.patchErrors(initOptions.errors);\n\n  return control as unknown as IFormControl<Value, Data>;\n}\n","import {\n  AbstractControlInterface,\n  ControlId,\n  isAbstractControl,\n  ValidationErrors,\n} from './abstract-control';\n\nimport { IAbstractControl } from './abstract-control';\n\nimport {\n  AbstractControlContainerInterface,\n  ControlsKey,\n  ControlsRawValue,\n  ControlsValue,\n  GenericControlsObject,\n  isAbstractControlContainer,\n} from './abstract-control-container';\n\nimport { IAbstractControlContainer } from './abstract-control-container';\n\nimport {\n  createAbstractControlBase,\n  IAbstractControlBaseOptions,\n} from './abstract-control-base';\n\nimport { produce, SetStoreFunction, Store } from 'solid-js/store';\nimport { Accessor, batch, createMemo } from 'solid-js';\nimport { isEqual, mergeObj } from './util';\nimport type { PartialDeep } from 'type-fest';\n\nexport interface IAbstractControlContainerBaseArgs<\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> extends IAbstractControlBaseOptions<Data> {}\n\nexport interface IAbstractControlContainerBase<\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> extends Omit<\n    IAbstractControlContainer<any, Data>,\n    | 'value'\n    | 'rawValue'\n    | 'controls'\n    | 'setControl'\n    | typeof AbstractControlInterface\n    | typeof AbstractControlContainerInterface\n  > {}\n\nexport function createAbstractControlContainerBase<\n  Controls extends GenericControlsObject = any,\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n>(\n  store: Accessor<\n    [\n      Store<IAbstractControlContainer<Controls, Data>>,\n      SetStoreFunction<IAbstractControlContainer<Controls, Data>>\n    ]\n  >,\n  untilInit: <T>(value: T) => T,\n  initOptions: IAbstractControlContainerBaseArgs<Data> = {}\n): [base: IAbstractControlContainerBase<Data>, initializer: () => void] {\n  let control: Store<IAbstractControlContainer<Controls, Data>>;\n  let setControl: SetStoreFunction<IAbstractControlContainer<Controls, Data>>;\n\n  const [base, initializeAbstractControl] = createAbstractControlBase<\n    ControlsRawValue<Controls>,\n    Data,\n    ControlsValue<Controls>\n  >(() => [control, setControl], untilInit, initOptions);\n\n  let sizeMemo: Accessor<number>;\n\n  let childIsValidMemo: Accessor<boolean>;\n  let childIsDisabledMemo: Accessor<boolean>;\n  let childIsReadonlyMemo: Accessor<boolean>;\n  let childIsRequiredMemo: Accessor<boolean>;\n  let childIsPendingMemo: Accessor<boolean>;\n  let childIsTouchedMemo: Accessor<boolean>;\n  let childIsDirtyMemo: Accessor<boolean>;\n  let childIsSubmittedMemo: Accessor<boolean>;\n\n  let childrenAreValidMemo: Accessor<boolean>;\n  let childrenAreDisabledMemo: Accessor<boolean>;\n  let childrenAreReadonlyMemo: Accessor<boolean>;\n  let childrenAreRequiredMemo: Accessor<boolean>;\n  let childrenArePendingMemo: Accessor<boolean>;\n  let childrenAreTouchedMemo: Accessor<boolean>;\n  let childrenAreDirtyMemo: Accessor<boolean>;\n  let childrenAreSubmittedMemo: Accessor<boolean>;\n\n  let errorsMemo: Accessor<ValidationErrors | null>;\n  let childrenErrorsMemo: Accessor<ValidationErrors | null>;\n\n  const containerBase = mergeObj(base, {\n    get size() {\n      return sizeMemo?.() ?? untilInit(0);\n    },\n\n    get isDisabled() {\n      return this.self.isDisabled || this.children.areDisabled;\n    },\n\n    get isTouched() {\n      return this.self.isTouched || this.child.isTouched;\n    },\n\n    get isDirty() {\n      return this.self.isDirty || this.child.isDirty;\n    },\n\n    get isReadonly() {\n      return this.self.isReadonly || this.children.areReadonly;\n    },\n\n    get isSubmitted() {\n      return this.self.isSubmitted || this.children.areSubmitted;\n    },\n\n    get isRequired() {\n      return this.self.isRequired || this.child.isRequired;\n    },\n\n    get isPending() {\n      return this.self.isPending || this.child.isPending;\n    },\n\n    get errors() {\n      return errorsMemo?.() ?? untilInit(null);\n    },\n\n    get isValid() {\n      return this.self.isValid && this.children.areValid;\n    },\n\n    child: {\n      /** Will return true if *any* `enabled` direct child control is `valid` */\n      get isValid() {\n        return childIsValidMemo?.() ?? untilInit(true);\n      },\n      /** Will return true if *any* direct child control is `disabled` */\n      get isDisabled() {\n        return childIsDisabledMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *any* `enabled` direct child control is `readonly` */\n      get isReadonly() {\n        return childIsReadonlyMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *any* `enabled` direct child control is `required` */\n      get isRequired() {\n        return childIsRequiredMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *any* `enabled` direct child control is `pending` */\n      get isPending() {\n        return childIsPendingMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *any* `enabled` direct child control is `touched` */\n      get isTouched() {\n        return childIsTouchedMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *any* `enabled` direct child control is `dirty` */\n      get isDirty() {\n        return childIsDirtyMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *any* `enabled` direct child control is `submitted` */\n      get isSubmitted() {\n        return childIsSubmittedMemo?.() ?? untilInit(false);\n      },\n    },\n\n    children: {\n      /** Will return true if *all* `enabled` direct child control's are `valid` */\n      get areValid() {\n        return childrenAreValidMemo?.() ?? untilInit(true);\n      },\n      /** Will return true if *all* direct child control's are `disabled` */\n      get areDisabled() {\n        return childrenAreDisabledMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *all* `enabled` direct child control's are `readonly` */\n      get areReadonly() {\n        return childrenAreReadonlyMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *all* `enabled` direct child control's are `required` */\n      get areRequired() {\n        return childrenAreRequiredMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *all* `enabled` direct child control's are `pending` */\n      get arePending() {\n        return childrenArePendingMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *all* `enabled` direct child control's are `touched` */\n      get areTouched() {\n        return childrenAreTouchedMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *all* `enabled` direct child control's are `dirty` */\n      get areDirty() {\n        return childrenAreDirtyMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *all* `enabled` direct child control's are `submitted` */\n      get areSubmitted() {\n        return childrenAreSubmittedMemo?.() ?? untilInit(false);\n      },\n      /** Contains *all* `enabled` child control errors or `null` if there are none */\n      get errors() {\n        return childrenErrorsMemo?.() ?? untilInit(null);\n      },\n\n      markDirty(value, options) {\n        batch(() => {\n          Object.values(control.controls).forEach((c) => {\n            (c as IAbstractControl).markDirty(value);\n\n            if (!options?.deep || !isAbstractControlContainer(c)) {\n              return;\n            }\n\n            c.children.markDirty(value, options);\n          });\n        });\n      },\n\n      markDisabled(value, options) {\n        batch(() => {\n          Object.values(control.controls).forEach((c) => {\n            (c as IAbstractControl).markDisabled(value);\n\n            if (!options?.deep || !isAbstractControlContainer(c)) {\n              return;\n            }\n\n            c.children.markDisabled(value, options);\n          });\n        });\n      },\n\n      markPending(value, options) {\n        batch(() => {\n          Object.values(control.controls).forEach((c) => {\n            (c as IAbstractControl).markPending(value, options);\n\n            if (!options?.deep || !isAbstractControlContainer(c)) {\n              return;\n            }\n\n            c.children.markPending(value, options);\n          });\n        });\n      },\n\n      markReadonly(value, options) {\n        batch(() => {\n          Object.values(control.controls).forEach((c) => {\n            (c as IAbstractControl).markReadonly(value);\n\n            if (!options?.deep || !isAbstractControlContainer(c)) {\n              return;\n            }\n\n            c.children.markReadonly(value, options);\n          });\n        });\n      },\n\n      markRequired(value, options) {\n        batch(() => {\n          Object.values(control.controls).forEach((c) => {\n            (c as IAbstractControl).markRequired(value);\n\n            if (!options?.deep || !isAbstractControlContainer(c)) {\n              return;\n            }\n\n            c.children.markRequired(value, options);\n          });\n        });\n      },\n\n      markSubmitted(value, options) {\n        batch(() => {\n          Object.values(control.controls).forEach((c) => {\n            (c as IAbstractControl).markSubmitted(value);\n\n            if (!options?.deep || !isAbstractControlContainer(c)) {\n              return;\n            }\n\n            c.children.markSubmitted(value, options);\n          });\n        });\n      },\n\n      markTouched(value, options) {\n        batch(() => {\n          Object.values(control.controls).forEach((c) => {\n            (c as IAbstractControl).markTouched(value);\n\n            if (!options?.deep || !isAbstractControlContainer(c)) {\n              return;\n            }\n\n            c.children.markTouched(value, options);\n          });\n        });\n      },\n    },\n\n    setControls(controls: Controls) {\n      if (isEqual(control.controls, controls)) return;\n\n      // We're using `produce()` here because using the standard solid Store\n      // nested setter has some bugs (i.e.\n      // `setControl('self', 'pendingStore', newPendingStore)`). I think the\n      // bugs are isolated to object values, so, at the moment, I'm only using\n      // produce where the value is an object.\n      setControl(\n        produce((state) => {\n          (state.controls as Controls) = controls;\n        })\n      );\n    },\n\n    /**\n     * The provided control is removed from this FormGroup\n     * if it is a child of this FormGroup. Or the control\n     * associated with the provided key is removed.\n     */\n    removeControl(\n      keyOrControl: ControlsKey<Controls> | Controls[ControlsKey<Controls>]\n    ) {\n      if (!isAbstractControl(keyOrControl)) {\n        control.setControl(keyOrControl as ControlsKey<Controls>, null);\n        return;\n      }\n\n      const childControl = keyOrControl;\n\n      for (const [key, c] of Object.entries(control.controls!)) {\n        if (c !== childControl) continue;\n\n        control.setControl(key as ControlsKey<Controls>, null);\n        return;\n      }\n    },\n\n    setValue(value: ControlsRawValue<Controls>) {\n      const valueEntries = Object.entries(value);\n\n      if (valueEntries.length !== control.size!) {\n        throw new Error(\n          `setValue error: you must provide a value for each control.`\n        );\n      }\n\n      batch(() => {\n        for (const [key, val] of valueEntries) {\n          const c = control.controls[\n            key as ControlsKey<Controls>\n          ] as unknown as IAbstractControl | undefined;\n\n          if (!c) {\n            throw new Error(`Invalid setValue value key \"${key}\".`);\n          }\n\n          c.setValue(val);\n        }\n      });\n    },\n\n    patchValue(value: PartialDeep<ControlsRawValue<Controls>>) {\n      batch(() => {\n        for (const [key, entryValue] of Object.entries(value)) {\n          const c = control.controls[\n            key as ControlsKey<Controls>\n          ] as unknown as IAbstractControl | undefined;\n\n          if (!c) {\n            throw new Error(`Invalid patchValue value key \"${key}\".`);\n          }\n\n          if (isAbstractControlContainer(c)) {\n            c.patchValue(entryValue);\n          } else {\n            c.setValue(entryValue);\n          }\n        }\n      });\n    },\n  } as IAbstractControlContainerBase<Data>);\n\n  const initializer = () => {\n    [control, setControl] = store();\n\n    initializeAbstractControl();\n\n    const allControlsMemo = createMemo(() => Object.values(control.controls));\n\n    const nonDisabledControlsMemo = createMemo(() =>\n      allControlsMemo().filter((c) => !c.isDisabled)\n    );\n\n    sizeMemo = createMemo(() => allControlsMemo().length);\n\n    childIsValidMemo = createMemo(() =>\n      nonDisabledControlsMemo().some((c) => c.isValid)\n    );\n\n    childIsDisabledMemo = createMemo(() =>\n      allControlsMemo().some((c) => c.isDisabled)\n    );\n\n    childIsReadonlyMemo = createMemo(() =>\n      nonDisabledControlsMemo().some((c) => c.isReadonly)\n    );\n\n    childIsRequiredMemo = createMemo(() =>\n      nonDisabledControlsMemo().some((c) => c.isRequired)\n    );\n\n    childIsPendingMemo = createMemo(() =>\n      nonDisabledControlsMemo().some((c) => c.isPending)\n    );\n\n    childIsTouchedMemo = createMemo(() =>\n      nonDisabledControlsMemo().some((c) => c.isTouched)\n    );\n\n    childIsDirtyMemo = createMemo(() =>\n      nonDisabledControlsMemo().some((c) => c.isDirty)\n    );\n\n    childIsSubmittedMemo = createMemo(() =>\n      nonDisabledControlsMemo().some((c) => c.isSubmitted)\n    );\n\n    childrenAreValidMemo = createMemo(() =>\n      nonDisabledControlsMemo().every((c) => c.isValid)\n    );\n\n    childrenAreDisabledMemo = createMemo(() => {\n      const controls = allControlsMemo();\n\n      if (controls.length === 0) return false;\n\n      return controls.every((c) => c.isDisabled);\n    });\n\n    childrenAreReadonlyMemo = createMemo(() => {\n      const controls = nonDisabledControlsMemo();\n\n      if (controls.length === 0) return false;\n\n      return controls.every((c) => c.isReadonly);\n    });\n\n    childrenAreRequiredMemo = createMemo(() => {\n      const controls = nonDisabledControlsMemo();\n\n      if (controls.length === 0) return false;\n\n      return controls.every((c) => c.isRequired);\n    });\n\n    childrenArePendingMemo = createMemo(() => {\n      const controls = nonDisabledControlsMemo();\n\n      if (controls.length === 0) return false;\n\n      return controls.every((c) => c.isPending);\n    });\n\n    childrenAreTouchedMemo = createMemo(() => {\n      const controls = nonDisabledControlsMemo();\n\n      if (controls.length === 0) return false;\n\n      return controls.every((c) => c.isTouched);\n    });\n\n    childrenAreDirtyMemo = createMemo(() => {\n      const controls = nonDisabledControlsMemo();\n\n      if (controls.length === 0) return false;\n\n      return controls.every((c) => c.isDirty);\n    });\n\n    childrenAreSubmittedMemo = createMemo(() => {\n      const controls = nonDisabledControlsMemo();\n\n      if (controls.length === 0) return false;\n\n      return controls.every((c) => c.isSubmitted);\n    });\n\n    errorsMemo = createMemo(() => {\n      if (!control.self.errors && !control.children.errors) return null;\n\n      return {\n        ...control.children.errors,\n        ...control.self.errors,\n      };\n    });\n\n    childrenErrorsMemo = createMemo(() => {\n      const controls = nonDisabledControlsMemo();\n\n      return controls.reduce((prev, curr) => {\n        return prev === null && curr.errors === null\n          ? null\n          : { ...prev, ...curr.errors };\n      }, null as ValidationErrors | null);\n    });\n  };\n\n  return [containerBase, initializer];\n}\n","import {\n  AbstractControlInterface,\n  ControlId,\n  IAbstractControl,\n} from './abstract-control';\nimport { createAbstractControlContainerBase } from './abstract-control-container-base';\nimport {\n  ControlsValue,\n  ControlsRawValue,\n  ControlsKey,\n  IAbstractControlContainer,\n  AbstractControlContainerInterface,\n  isAbstractControlContainer,\n} from './abstract-control-container';\nimport {\n  IAbstractControlBaseOptions,\n  propInitializer,\n} from './abstract-control-base';\nimport { createStore, produce, SetStoreFunction, Store } from 'solid-js/store';\nimport { Accessor, createMemo } from 'solid-js';\nimport { isEqual, mergeObj } from './util';\nimport type { PartialDeep } from 'type-fest';\n\nexport const FormGroupInterface = '@@FormGroupInterface_solidjs';\n\nexport interface IFormGroupOptions<\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> extends IAbstractControlBaseOptions<Data> {}\n\nexport interface IFormGroup<\n  Controls extends { [key: string]: IAbstractControl } = {\n    [key: string]: IAbstractControl;\n  },\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> extends IAbstractControlContainer<Controls, Data> {\n  [FormGroupInterface]: true;\n  setControls(controls: Controls): void;\n  removeControl(\n    keyOrControl: ControlsKey<Controls> | Controls[ControlsKey<Controls>]\n  ): void;\n  patchValue(value: PartialDeep<ControlsRawValue<Controls>>): void;\n}\n\n/**\n * Returns true if the provided object implements\n * `IFormGroup`\n */\nexport function isFormGroup(object?: unknown): object is IFormGroup {\n  return (\n    isAbstractControlContainer(object) &&\n    (object as any)?.[FormGroupInterface] === true\n  );\n}\n\nexport function createFormGroup<\n  Controls extends { [key: string]: IAbstractControl } = {\n    [key: string]: IAbstractControl;\n  },\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n>(\n  controls?: Controls,\n  options?: IFormGroupOptions<Data>\n): IFormGroup<Controls, Data>;\nexport function createFormGroup<\n  Controls extends { [key: string]: IAbstractControl } = {\n    [key: string]: IAbstractControl;\n  },\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n>(\n  initControls = {} as Controls,\n  initOptions: IFormGroupOptions<Data> = {}\n): IFormGroup<Controls, Data> {\n  let control: Store<IFormGroup<Controls, Data>>;\n  let setControl: SetStoreFunction<IFormGroup<Controls, Data>>;\n\n  const [untilInit, initComplete] = propInitializer();\n\n  const [base, initializeBase] = createAbstractControlContainerBase(\n    () => [control, setControl],\n    untilInit,\n    initOptions\n  );\n\n  let rawValueMemo: Accessor<ControlsRawValue<Controls>>;\n  let valueMemo: Accessor<ControlsValue<Controls>>;\n\n  const storeConfig = mergeObj(base, {\n    [AbstractControlInterface]: true,\n    [AbstractControlContainerInterface]: true,\n    [FormGroupInterface]: true,\n\n    controls: initControls,\n\n    get rawValue() {\n      return rawValueMemo?.() ?? untilInit({});\n    },\n\n    get value() {\n      return valueMemo?.() ?? untilInit({});\n    },\n\n    setControl<N extends ControlsKey<Controls>>(\n      key: N,\n      newControl: Controls[N] | null\n    ) {\n      if (\n        newControl === null\n          ? !control.controls[key]\n          : isEqual(control.controls[key], newControl)\n      ) {\n        return;\n      }\n\n      setControl(\n        produce((state) => {\n          if (newControl === null) {\n            delete state.controls[key];\n          } else {\n            state.controls[key] = newControl;\n          }\n        })\n      );\n    },\n  } as IFormGroup<Controls, Data>);\n\n  [control, setControl] = createStore(storeConfig);\n\n  initializeBase();\n\n  const allControlEntriesMemo = createMemo(() =>\n    Object.entries(control.controls)\n  );\n\n  const enabledControlEntriesMemo = createMemo(() =>\n    allControlEntriesMemo().filter(([, c]) => !c.isDisabled)\n  );\n\n  rawValueMemo = createMemo(\n    () =>\n      Object.fromEntries(\n        allControlEntriesMemo().map(([k, c]) => [k, c.rawValue])\n      ) as ControlsRawValue<Controls>\n  );\n\n  valueMemo = createMemo(\n    () =>\n      Object.fromEntries(\n        enabledControlEntriesMemo().map(([k, c]) => [k, c.value])\n      ) as ControlsValue<Controls>\n  );\n\n  initComplete();\n\n  // Intentionally not using `batch()` since it appears to mess with\n  // initializing a control with errors\n  if (initOptions.disabled) control.markDisabled(initOptions.disabled);\n  if (initOptions.touched) control.markTouched(initOptions.touched);\n  if (initOptions.dirty) control.markDirty(initOptions.dirty);\n  if (initOptions.readonly) control.markReadonly(initOptions.readonly);\n  if (initOptions.submitted) control.markSubmitted(initOptions.submitted);\n  if (initOptions.required) control.markRequired(initOptions.required);\n  if (initOptions.pending) control.markPending(initOptions.pending);\n  if (initOptions.validators) control.setValidators(initOptions.validators);\n  if (initOptions.pending) control.markPending(initOptions.pending);\n  // this needs to be last to ensure that the errors aren't overwritten\n  if (initOptions.errors) control.patchErrors(initOptions.errors);\n\n  return control as unknown as IFormGroup<Controls, Data>;\n}\n","import {\n  AbstractControlInterface,\n  ControlId,\n  IAbstractControl,\n} from './abstract-control';\nimport { createAbstractControlContainerBase } from './abstract-control-container-base';\nimport {\n  ControlsValue,\n  ControlsRawValue,\n  ControlsKey,\n  IAbstractControlContainer,\n  AbstractControlContainerInterface,\n  isAbstractControlContainer,\n} from './abstract-control-container';\nimport {\n  IAbstractControlBaseOptions,\n  propInitializer,\n} from './abstract-control-base';\nimport { createStore, produce, SetStoreFunction, Store } from 'solid-js/store';\nimport { Accessor, batch, createMemo } from 'solid-js';\nimport { isEqual, mergeObj } from './util';\nimport type { PartialDeep } from 'type-fest';\n\nexport const FormArrayInterface = '@@FormArrayInterface_solidjs';\n\nexport interface IFormArrayOptions<\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> extends IAbstractControlBaseOptions<Data> {}\n\nexport interface IFormArray<\n  Controls extends ReadonlyArray<IAbstractControl> = ReadonlyArray<IAbstractControl>,\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> extends IAbstractControlContainer<Controls, Data> {\n  [FormArrayInterface]: true;\n  push(control: Controls[number]): void;\n  setControls(controls: Controls): void;\n  removeControl(\n    keyOrControl: ControlsKey<Controls> | Controls[ControlsKey<Controls>]\n  ): void;\n  patchValue(value: PartialDeep<ControlsRawValue<Controls>>): void;\n}\n\n/**\n * Returns true if the provided object implements\n * `IFormArray`\n */\nexport function isFormArray(object?: unknown): object is IFormArray {\n  return (\n    isAbstractControlContainer(object) &&\n    (object as any)?.[FormArrayInterface] === true\n  );\n}\n\nexport function createFormArray<\n  Controls extends ReadonlyArray<IAbstractControl> = ReadonlyArray<IAbstractControl>,\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n>(\n  controls?: Controls,\n  options?: IFormArrayOptions<Data>\n): IFormArray<Controls, Data>;\nexport function createFormArray<\n  Controls extends ReadonlyArray<IAbstractControl> = ReadonlyArray<IAbstractControl>,\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n>(\n  initControls = [] as unknown as Controls,\n  initOptions: IFormArrayOptions<Data> = {}\n): IFormArray<Controls, Data> {\n  let control: Store<IFormArray<Controls, Data>>;\n  let setControl: SetStoreFunction<IFormArray<Controls, Data>>;\n\n  const [untilInit, initComplete] = propInitializer();\n\n  const [base, initializeBase] = createAbstractControlContainerBase(\n    () => [control, setControl],\n    untilInit,\n    initOptions\n  );\n\n  let rawValueMemo: Accessor<ControlsRawValue<Controls>>;\n  let valueMemo: Accessor<ControlsValue<Controls>>;\n\n  const storeConfig = mergeObj(base, {\n    [AbstractControlInterface]: true,\n    [AbstractControlContainerInterface]: true,\n    [FormArrayInterface]: true,\n\n    controls: initControls,\n\n    get rawValue() {\n      return rawValueMemo?.() ?? untilInit({});\n    },\n\n    get value() {\n      return valueMemo?.() ?? untilInit({});\n    },\n\n    setControl<N extends ControlsKey<Controls>>(\n      key: N,\n      newControl: Controls[N] | null\n    ) {\n      if (\n        newControl === null\n          ? !control.controls[key]\n          : isEqual(control.controls[key], newControl)\n      ) {\n        return;\n      }\n\n      setControl(\n        produce((state) => {\n          if (newControl === null) {\n            (\n              state.controls as unknown as Array<\n                typeof state['controls'][number]\n              >\n            ).splice(key, 1);\n          } else {\n            state.controls[key] = newControl;\n          }\n        })\n      );\n    },\n\n    push(control: Controls[number]) {\n      this.setControl(this.controls.length, control);\n    },\n  } as IFormArray<Controls, Data>);\n\n  [control, setControl] = createStore(storeConfig);\n\n  initializeBase();\n\n  const enabledControlsMemo = createMemo(() =>\n    control.controls.filter((c) => !c.isDisabled)\n  );\n\n  rawValueMemo = createMemo(\n    () =>\n      (control as IFormArray<Controls, Data>).controls.map(\n        (c) => c.rawValue\n      ) as unknown as ControlsRawValue<Controls>\n  );\n\n  valueMemo = createMemo(\n    () =>\n      enabledControlsMemo().map(\n        (c) => c.value\n      ) as unknown as ControlsValue<Controls>\n  );\n\n  initComplete();\n\n  // Intentionally not using `batch()` since it appears to mess with\n  // initializing a control with errors\n  if (initOptions.disabled) control.markDisabled(initOptions.disabled);\n  if (initOptions.touched) control.markTouched(initOptions.touched);\n  if (initOptions.dirty) control.markDirty(initOptions.dirty);\n  if (initOptions.readonly) control.markReadonly(initOptions.readonly);\n  if (initOptions.submitted) control.markSubmitted(initOptions.submitted);\n  if (initOptions.required) control.markRequired(initOptions.required);\n  if (initOptions.pending) control.markPending(initOptions.pending);\n  if (initOptions.validators) control.setValidators(initOptions.validators);\n  if (initOptions.pending) control.markPending(initOptions.pending);\n  // this needs to be last to ensure that the errors aren't overwritten\n  if (initOptions.errors) control.patchErrors(initOptions.errors);\n\n  return control as unknown as IFormArray<Controls, Data>;\n}\n"],"names":["AbstractControlInterface","isAbstractControl","object","AbstractControlContainerInterface","isAbstractControlContainer","isEqual","a","b","_isEqual","mergeObj","Object","defineProperties","getOwnPropertyDescriptors","bindOwner","fn","owner","getOwner","Error","runWithOwner","DEFAULT_SOURCE","propInitializer","createSignal","initializationSignal","setInitializationSignal","value","composeValidators","validators","Array","isArray","length","control","reduce","prev","curr","errors","controlId","createAbstractControlBase","store","untilInit","initOptions","setControl","selfIsPendingMemo","selfErrorsMemo","statusMemo","validatorMemo","base","id","Symbol","data","self","isValid","isPending","isDisabled","isTouched","isDirty","isReadonly","isSubmitted","isRequired","errorsStore","Map","pendingStore","Set","validatorStore","status","validator","markDisabled","input","markReadonly","markRequired","markDirty","markTouched","markSubmitted","markPending","options","newPendingStore","source","has","add","produce","state","setErrors","existingStore","newErrorsStore","keys","set","patchErrors","newErrors","existingValue","get","_objectSpread","entries","k","err","filter","v","fromEntries","setValidators","newValidatorsStore","newValidator","setData","key","initializer","createMemo","size","from","values","p","c","e","createComputed","on","rawValue","FormControlInterface","isFormControl","createFormControl","initValue","initComplete","initializeBase","storeConfig","createStore","disabled","touched","dirty","readonly","submitted","required","pending","createAbstractControlContainerBase","initializeAbstractControl","sizeMemo","childIsValidMemo","childIsDisabledMemo","childIsReadonlyMemo","childIsRequiredMemo","childIsPendingMemo","childIsTouchedMemo","childIsDirtyMemo","childIsSubmittedMemo","childrenAreValidMemo","childrenAreDisabledMemo","childrenAreReadonlyMemo","childrenAreRequiredMemo","childrenArePendingMemo","childrenAreTouchedMemo","childrenAreDirtyMemo","childrenAreSubmittedMemo","errorsMemo","childrenErrorsMemo","containerBase","children","areDisabled","child","areReadonly","areSubmitted","areValid","areRequired","arePending","areTouched","areDirty","batch","controls","forEach","deep","setControls","removeControl","keyOrControl","childControl","setValue","valueEntries","val","patchValue","entryValue","allControlsMemo","nonDisabledControlsMemo","some","every","FormGroupInterface","isFormGroup","createFormGroup","initControls","rawValueMemo","valueMemo","newControl","allControlEntriesMemo","enabledControlEntriesMemo","map","FormArrayInterface","isFormArray","createFormArray","splice","enabledControlsMemo"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"index.module.js","sources":["../../src/abstract-control.ts","../../src/abstract-control-container.ts","../../src/util.ts","../../src/abstract-control-base.ts","../../src/form-control.ts","../../src/abstract-control-container-base.ts","../../src/form-group.ts","../../src/form-array.ts"],"sourcesContent":["// *****************************\n// Misc Types\n// *****************************\n\nexport type ControlId = string | symbol;\n\nexport type ValidatorFn<T = any> = (rawValue: T) => ValidationErrors | null;\n\nexport interface ValidationErrors {\n  [key: string]: any;\n}\n\n// *****************************\n// AbstractControl interface\n// *****************************\n\nexport const AbstractControlInterface = '@@AbstractControlInterface_solidjs';\n\n/** Returns true if the provided object implements `IAbstractControl` */\nexport function isAbstractControl(\n  object?: unknown\n): object is IAbstractControl {\n  return (\n    typeof object === 'object' &&\n    (object as any)?.[AbstractControlInterface] === true\n  );\n}\n\nexport interface IAbstractControl<\n  RawValue = any,\n  Data extends Record<ControlId, any> = Record<ControlId, any>,\n  Value = RawValue\n> {\n  /**\n   * The ID is used to determine where StateChanges originated,\n   * and to ensure that a given AbstractControl only processes\n   * values one time.\n   */\n  readonly id: ControlId;\n\n  /**\n   * The data property can store arbitrary custom data. Use the\n   * `setData` method on `IAbstractControl` to update it.\n   *\n   * The `data` property is, itself, an object. You can set individual\n   * keys on the data property with `setData` but you cannot reset\n   * or clear the whole object. This is intentional. A library\n   * maintainer can store private data within the `data` property\n   * using a symbol without fear of the user accidently erasing it.\n   */\n  readonly data: Data;\n\n  /**\n   * The value of the IAbstractControl.\n   *\n   * In an IAbstractControlContainer,\n   * `value` and `rawValue` can be different, but in a standard\n   * `IAbstractControl` `value` is just an alias for `rawValue`.\n   * See the IAbstractControlContainer interface for possible differences\n   * between `value` and `rawValue`.\n   */\n  readonly value: Value;\n\n  /**\n   * The value of the IAbstractControl.\n   *\n   * In an IAbstractControlContainer,\n   * `value` and `rawValue` can be different, but in a standard\n   * `IAbstractControl` `value` is just an alias for `rawValue` and\n   * rawValue just contains the control's value.\n   * See the IAbstractControlContainer interface for possible differences\n   * between `value` and `rawValue`.\n   */\n  readonly rawValue: RawValue;\n\n  /**\n   * `true` if this control is disabled, false otherwise.\n   * This is an alias for `self.isDisabled`.\n   */\n  readonly isDisabled: boolean;\n\n  /**\n   * `true` if this control is touched, false otherwise.\n   * This is an alias for `self.isTouched`.\n   */\n  readonly isTouched: boolean;\n\n  /**\n   * `true` if this control is dirty, false otherwise.\n   * This is an alias for `self.isDirty`.\n   */\n  readonly isDirty: boolean;\n  /**\n   * `true` if this control is readonly, false otherwise.\n   * This is an alias for `self.isReadonly`.\n   */\n  readonly isReadonly: boolean;\n  /**\n   * `true` if this control is submitted, false otherwise.\n   * This is an alias for `self.isSubmitted`.\n   */\n  readonly isSubmitted: boolean;\n  /**\n   * `true` if this control is required, false otherwise.\n   * This is an alias for `self.isRequired`.\n   *\n   * Note that this property doesn't\n   * have any predefined meaning for IAbstractControls and it doesn't affect\n   * validation in any way. It is up to you to decide what meaning, if any,\n   * to give to this property and how to use it. For example, if you\n   * validated the control inside a `createEffect()`, you could choose to alter the\n   * validation based on whether the control was marked as `required` or\n   * not.\n   */\n  readonly isRequired: boolean;\n\n  /**\n   * Contains a `ValidationErrors` object if this control\n   * has any errors. Otherwise contains `null`.\n   *\n   * An alias for `self.errors`.\n   */\n  readonly errors: ValidationErrors | null;\n\n  /**\n   * A validator function that is run on rawValue changes and which\n   * generates errors associated with the source \"CONTROL_DEFAULT_SOURCE\".\n   */\n  readonly validator: ValidatorFn | null;\n\n  /**\n   * `true` if this control is pending, false otherwise.\n   * This is an alias for `self.isPending`.\n   */\n  readonly isPending: boolean;\n\n  /**\n   * Valid if `errors === null && !isPending`\n   *\n   * This is an alias for `self.valid`.\n   */\n  readonly isValid: boolean;\n\n  /**\n   * The `self` object on an abstract control contains\n   * properties reflecting the control's personal state. On an\n   * IAbstractControlContainer, the personal state can differ\n   * from the control's state. For example, an\n   * IAbstractControlContainer will register as disabled if\n   * the control itself has been marked as disabled OR if\n   * all of it's child controls are disabled.\n   *\n   * Marking the control container\n   * itself as disabled doesn't mark the container's children as\n   * disabled. On a standard IAbstractControl though,\n   * the \"self\" properties are the same as regular properties.\n   * I.e. `self.isInvalid` is the same as `isInvalid` on a\n   * standard IAbstractControl (actually, `isInvalid` is\n   * an alias for `self.isInvalid` on a standard control).\n   */\n  readonly self: {\n    /** `this.self.errors === null && !this.self.isPending` */\n    readonly isValid: boolean;\n\n    /** `true` if this control is disabled, false otherwise. */\n    readonly isDisabled: boolean;\n\n    /** `true` if this control is touched, false otherwise. */\n    readonly isTouched: boolean;\n\n    /**\n     * `true` if this control is dirty, false otherwise.\n     *\n     * Dirty can be thought of as, \"Has the value changed?\"\n     * Though the isDirty property must be manually set by\n     * the user (using `markDirty()`) and is not automatically\n     * updated.\n     */\n    readonly isDirty: boolean;\n    /**\n     * `true` if this control is readonly, false otherwise.\n     *\n     * This property does not have any predefined meeting for\n     * an IAbstractControl. You can decide if you want to give\n     * it meaning by, for example, using this value to set\n     * an input's readonly status (e.g.\n     * `<input readonly={control.isReadonly} />`)\n     */\n    readonly isReadonly: boolean;\n\n    /** `true` if this control is submitted, false otherwise. */\n    readonly isSubmitted: boolean;\n\n    /**\n     * `true` if this control is required, false otherwise.\n     *\n     * Note that this property doesn't\n     * have any predefined meaning for IAbstractControls and it doesn't affect\n     * validation in any way. It is up to you to decide what meaning, if any,\n     * to give to this property and how to use it. For example, if you\n     * validated the control inside a `createEffect()` you could alter the\n     * validation based on whether the control was marked as `required` or\n     * not.\n     */\n    readonly isRequired: boolean;\n\n    /** `true` if this control is pending, false otherwise. */\n    readonly isPending: boolean;\n\n    /**\n     * Contains a `ValidationErrors` object if this control\n     * has any errors. Otherwise contains `null`.\n     */\n    readonly errors: ValidationErrors | null;\n\n    /**\n     * *More advanced-ish*\n     *\n     * Contains a map of ControlId values and ValidationErrors.\n     * The errorsStore allows partitioning errors so that\n     * they can be associated with different sources and so\n     * that one source does not overwrite another source.\n     *\n     * The `self.errors` property gets its errors from the errorsStore.\n     */\n    readonly errorsStore: ReadonlyMap<ControlId, ValidationErrors>;\n\n    /**\n     * More advanced-ish*\n     *\n     * A set of ControlIds. `self.isPending` is true so long\n     * as `pendingStore.size > 0`. Because this is a set, you\n     * can track multiple pending \"things\" at once. This\n     * control will register as pending until all of the \"things\"\n     * have resolved. Use the `markPending()` method with\n     * the `source` option to update the pendingStore.\n     */\n    readonly pendingStore: ReadonlySet<ControlId>;\n\n    /**\n     * More advanced-ish*\n     *\n     * A map of ControlIds and ValidatorFns. The `validator`\n     * property is composed of all the validator functions in the\n     * `validatorStore`. The validatorStore allows you to change\n     * individual validator functions on the control without\n     * affecting other validator functions on the control.\n     *\n     * When you use the `setValidators` method, you are updating\n     * the validatorStore.\n     */\n    readonly validatorStore: ReadonlyMap<ControlId, ValidatorFn>;\n  };\n\n  /**\n   * If this control is disabled, the status is `\"DISABLED\"`,\n   * else if this control is pending, the status is `\"PENDING\"`,\n   * else if this control has any errors, the status is `\"INVALID\"`,\n   * else the status is `\"VALID\"`.\n   */\n  readonly status: 'DISABLED' | 'PENDING' | 'INVALID' | 'VALID';\n\n  [AbstractControlInterface]: true;\n\n  /** set the control's value  */\n  setValue(value: RawValue): void;\n\n  /**\n   * If provided a `ValidationErrors` object or `null`, replaces `self.errors`.\n   * Optionally, provide a source ID and the change will be partitioned\n   * assocaited with the source ID. The default source ID is\n   * \"CONTROL_DEFAULT_SOURCE\".\n   *\n   * If you provide a `Map` object containing `ValidationErrors` keyed to source IDs,\n   * that will replace the `self.errorsStore` associated with this control.\n   */\n  setErrors(\n    value: ValidationErrors | null | ReadonlyMap<ControlId, ValidationErrors>,\n    options?: { source?: ControlId }\n  ): void;\n\n  /**\n   * If you provide a `ValidationErrors` object, that object is merged with the\n   * existing errors associated with the source ID. If the error object has\n   * keys equal to `null`, errors associated with those keys are deleted\n   * from the errors object.\n   *\n   * If you provide a `Map` object containing `ValidationErrors` keyed to source IDs,\n   * that object is merged with the existing `errorsStore`.\n   */\n  patchErrors(\n    value: ValidationErrors | ReadonlyMap<ControlId, ValidationErrors>,\n    options?: { source?: ControlId }\n  ): void;\n\n  /** sets `self.isTouched` */\n  markTouched(value: boolean): void;\n\n  /** sets `self.isDirty` */\n  markDirty(value: boolean): void;\n\n  /** sets `self.isReadonly` */\n  markReadonly(value: boolean): void;\n\n  /**\n   * Sets `self.isRequired`.\n   *\n   * Note that this property doesn't\n   * have any predefined meaning for IAbstractControls and it doesn't affect\n   * validation in any way. It is up to you to decide what meaning, if any,\n   * to give to this property and how to use it. For example, if you\n   * validated the control inside a `createEffect()` you could alter the\n   * validation based on whether the control was marked as `required` or\n   * not.\n   */\n  markRequired(value: boolean): void;\n\n  /**\n   * Set `self.isDisabled`.\n   *\n   * Note that `self.isDisabled`` affect's the control's `status`\n   * property. Additionally, `IAbstractControlContainer's` ignore\n   * disabled children in many cases. For example, the `value` of a\n   * control container is equal to the value of it's _enabled_ children\n   * (if you want to see the value including disabled children, use\n   * `rawValue`).\n   */\n  markDisabled(value: boolean): void;\n\n  /** sets `self.isSubmitted` */\n  markSubmitted(value: boolean): void;\n\n  /** sets `self.pendingStore` and `self.isPending` */\n  markPending(\n    value: boolean | ReadonlySet<ControlId>,\n    options?: { source?: ControlId }\n  ): void;\n\n  /** sets `validator` and `self.validatorStore` */\n  setValidators(\n    value:\n      | ValidatorFn\n      | ValidatorFn[]\n      | ReadonlyMap<ControlId, ValidatorFn>\n      | null,\n    options?: { source?: ControlId }\n  ): void;\n\n  /**\n   * The data property can store arbitrary custom data. Use the\n   * `setData` method on `IAbstractControl` to update it.\n   *\n   * The `data` property is, itself, an object. You can set individual\n   * keys on the data property with `setData` but you cannot reset\n   * or clear the whole object. This is intentional. A library\n   * maintainer can store private data within the `data` property\n   * using a symbol without fear of the user accidently erasing it.\n   */\n  setData<K extends keyof Data>(key: K, data: Data[K]): void;\n}\n","import {\n  ControlId,\n  isAbstractControl,\n  ValidationErrors,\n} from './abstract-control';\nimport { IAbstractControl } from './abstract-control';\n\n// UTILITY TYPES\n\ntype PickUndefinedKeys<T> = {\n  [K in keyof T]: undefined extends T[K] ? K : never;\n}[keyof T];\n\ntype PickRequiredKeys<T> = {\n  [K in keyof T]: undefined extends T[K] ? never : K;\n}[keyof T];\n\ntype ObjectControlsOptionalRawValue<\n  T extends { [key: string]: IAbstractControl | undefined }\n> = {\n  [P in Exclude<PickUndefinedKeys<T>, undefined>]?: NonNullable<\n    T[P]\n  >['rawValue'];\n};\n\ntype ObjectControlsRequiredRawValue<\n  T extends { [key: string]: IAbstractControl | undefined }\n> = {\n  [P in Exclude<PickRequiredKeys<T>, undefined>]: NonNullable<T[P]>['rawValue'];\n};\n\ntype ArrayControlsRawValue<T extends ReadonlyArray<IAbstractControl>> =\n  T extends ReadonlyArray<infer C>\n    ? C extends IAbstractControl\n      ? ReadonlyArray<C['rawValue']>\n      : never\n    : never;\n\ntype ObjectControlsOptionalValue<\n  T extends { [key: string]: IAbstractControl | undefined }\n> = {\n  [P in Exclude<PickUndefinedKeys<T>, undefined>]?: NonNullable<T[P]>['value'];\n};\n\ntype ObjectControlsRequiredValue<\n  T extends { [key: string]: IAbstractControl | undefined }\n> = {\n  [P in Exclude<PickRequiredKeys<T>, undefined>]: NonNullable<T[P]>['value'];\n};\n\ntype ArrayControlsValue<T extends ReadonlyArray<IAbstractControl>> =\n  T extends ReadonlyArray<infer C>\n    ? C extends IAbstractControl\n      ? ReadonlyArray<C['value']>\n      : never\n    : never;\n\n// END UTILITY TYPES\n\nexport type GenericControlsObject =\n  | {\n      readonly [key: string]: IAbstractControl;\n    }\n  | ReadonlyArray<IAbstractControl>;\n\n// need to add the `keyof ControlsRawValue<Controls>` as well as\n// `keyof ControlsValue<Controls>` as well as the `keyof Controls` etc\n// because typescript doesn't realize that all three are the same keys\n// and without all three, then ControlsKey can't be used to index all three\nexport type ControlsKey<Controls extends GenericControlsObject> =\n  keyof ControlsRawValue<Controls> &\n    keyof ControlsValue<Controls> &\n    (Controls extends ReadonlyArray<any>\n      ? keyof Controls & number\n      : Controls extends object\n      ? // the `& string` is needed or else\n        // ControlsKey<{[key: string]: AbstractControl}> is type string | number\n        keyof Controls & string\n      : any);\n\nexport type ControlsRawValue<Controls extends GenericControlsObject> =\n  Controls extends ReadonlyArray<IAbstractControl>\n    ? ArrayControlsRawValue<Controls>\n    : Controls extends { readonly [key: string]: IAbstractControl | undefined }\n    ? ObjectControlsRequiredRawValue<Controls> &\n        ObjectControlsOptionalRawValue<Controls>\n    : never;\n\nexport type ControlsValue<Controls extends GenericControlsObject> =\n  Controls extends ReadonlyArray<IAbstractControl>\n    ? ArrayControlsValue<Controls>\n    : Controls extends { readonly [key: string]: IAbstractControl | undefined }\n    ? Partial<\n        ObjectControlsRequiredValue<Controls> &\n          ObjectControlsOptionalValue<Controls>\n      >\n    : never;\n\nexport type ContainerControls<C> = C extends IAbstractControlContainer<\n  infer Controls\n>\n  ? Controls\n  : unknown;\n\nexport const AbstractControlContainerInterface =\n  '@@AbstractControlContainerInterface_solidjs';\n\n/**\n * Returns true if the provided object implements\n * `IAbstractControlContainer`\n */\nexport function isAbstractControlContainer(\n  object?: unknown\n): object is IAbstractControlContainer {\n  return (\n    isAbstractControl(object) &&\n    (object as any)[AbstractControlContainerInterface]\n  );\n}\n\nexport interface IAbstractControlContainer<\n  Controls extends GenericControlsObject = any,\n  Data = any\n> extends IAbstractControl<\n    ControlsRawValue<Controls>,\n    Data,\n    ControlsValue<Controls>\n  > {\n  /** Child controls associated with this container */\n  readonly controls: Controls;\n\n  /** The number of controls associated with this container */\n  readonly size: number;\n\n  /** Only returns values for enabled child controls. */\n  readonly value: ControlsValue<Controls>;\n\n  /**\n   * Returns values for both enabled and disabled child controls.\n   */\n  readonly rawValue: ControlsRawValue<Controls>;\n\n  /** Will return true if `this.self.isValid` and `this.children.areValid` */\n  readonly isValid: boolean;\n\n  /** Will return true if `this.self.isDisabled` or `this.children.areDisabled` */\n  readonly isDisabled: boolean;\n\n  /** Will return true if `this.self.isReadonly` or `this.children.areReadonly` */\n  readonly isReadonly: boolean;\n\n  /** Will return true if `this.self.isRequired` or `this.child.isRequired` */\n  readonly isRequired: boolean;\n\n  /** Will return true if `this.self.isPending` or `this.child.isPending` */\n  readonly isPending: boolean;\n\n  /** Will return true if `this.self.isTouched` or `this.child.isTouched` */\n  readonly isTouched: boolean;\n\n  /** Will return true if `this.self.isDirty` or `this.child.isDirty` */\n  readonly isDirty: boolean;\n\n  /** Will return true if `this.self.isSubmitted` or `this.children.areSubmitted` */\n  readonly isSubmitted: boolean;\n\n  /** Contains `{ ...this.children.errors, ...this.self.errors }` or `null` if there are none */\n  readonly errors: ValidationErrors | null;\n\n  readonly child: {\n    /** Will return true if *any* `enabled` direct child control is `valid` */\n    readonly isValid: boolean;\n    /** Will return true if *any* direct child control is `disabled` */\n    readonly isDisabled: boolean;\n    /** Will return true if *any* `enabled` direct child control is `readonly` */\n    readonly isReadonly: boolean;\n    /** Will return true if *any* `enabled` direct child control is `required` */\n    readonly isRequired: boolean;\n    /** Will return true if *any* `enabled` direct child control is `pending` */\n    readonly isPending: boolean;\n    /** Will return true if *any* `enabled` direct child control is `touched` */\n    readonly isTouched: boolean;\n    /** Will return true if *any* `enabled` direct child control is `dirty` */\n    readonly isDirty: boolean;\n    /** Will return true if *any* `enabled` direct child control is `submitted` */\n    readonly isSubmitted: boolean;\n  };\n\n  readonly children: {\n    /** Will return true if *all* `enabled` direct child control's are `valid` */\n    readonly areValid: boolean;\n    /** Will return true if *all* direct child control's are `disabled` */\n    readonly areDisabled: boolean;\n    /** Will return true if *all* `enabled` direct child control's are `readonly` */\n    readonly areReadonly: boolean;\n    /** Will return true if *all* `enabled` direct child control's are `required` */\n    readonly areRequired: boolean;\n    /** Will return true if *all* `enabled` direct child control's are `pending` */\n    readonly arePending: boolean;\n    /** Will return true if *all* `enabled` direct child control's are `touched` */\n    readonly areTouched: boolean;\n    /** Will return true if *all* `enabled` direct child control's are `dirty` */\n    readonly areDirty: boolean;\n    /** Will return true if *all* `enabled` direct child control's are `submitted` */\n    readonly areSubmitted: boolean;\n    /** Contains *all* `enabled` child control errors or `null` if there are none */\n    readonly errors: ValidationErrors | null;\n\n    /**\n     * Mark all direct children as disabled. Use the `deep: true`\n     * option to instead mark all direct and indirect children\n     * as disabled.\n     */\n    markDisabled(value: boolean, options?: { deep?: boolean }): void;\n\n    /**\n     * Mark all direct children as touched. Use the `deep: true`\n     * option to instead mark all direct and indirect children\n     * as touched.\n     */\n    markTouched(value: boolean, options?: { deep?: boolean }): void;\n\n    /**\n     * Mark all direct children as dirty. Use the `deep: true`\n     * option to instead mark all direct and indirect children\n     * as dirty.\n     */\n    markDirty(value: boolean, options?: { deep?: boolean }): void;\n\n    /**\n     * Mark all direct children as readonly. Use the `deep: true`\n     * option to instead mark all direct and indirect children\n     * as readonly.\n     */\n    markReadonly(value: boolean, options?: { deep?: boolean }): void;\n\n    /**\n     * Mark all direct children as required. Use the `deep: true`\n     * option to instead mark all direct and indirect children\n     * as required.\n     */\n    markRequired(value: boolean, options?: { deep?: boolean }): void;\n\n    /**\n     * Mark all direct children as submitted. Use the `deep: true`\n     * option to instead mark all direct and indirect children\n     * as submitted.\n     */\n    markSubmitted(value: boolean, options?: { deep?: boolean }): void;\n\n    /**\n     * Mark all direct children as pending. Use the `deep: true`\n     * option to instead mark all direct and indirect children\n     * as pending.\n     */\n    markPending(\n      value: boolean,\n      options?: { source?: ControlId; deep?: boolean }\n    ): void;\n  };\n\n  [AbstractControlContainerInterface]: true;\n\n  /**\n   * Apply a partial update to the values of some children but\n   * not all.\n   */\n  patchValue(value: unknown): void;\n\n  /** sets the `controls` property */\n  setControls(controls: Controls): void;\n\n  /** stores the provided control in `controls[key]` */\n  setControl(key: unknown, control: unknown): void;\n\n  /**\n   * If provided a control value, removes the given control from\n   * `controls`. If provided a control key value, removes the\n   * control associated with the given key from `controls`.\n   */\n  removeControl(keyOrControl: unknown): void;\n}\n","import _isEqual from 'deep-equal';\nimport { getOwner, runWithOwner } from 'solid-js';\nimport type { Merge } from 'type-fest';\n\nexport function isEqual<T>(a: T, b: any): b is T {\n  return _isEqual(a, b);\n}\n\nexport function mergeObj<A, B>(a: A, b: Merge<Partial<A>, B>): Merge<A, B> {\n  return Object.defineProperties(\n    a,\n    Object.getOwnPropertyDescriptors(b)\n  ) as unknown as Merge<A, B>;\n}\n\n/**\n * Helper to bind the owner of the current context to the\n * supplied function.\n *\n * Implementation is very simple:\n * ```ts\n * import { getOwner, runWithOwner } from 'solid-js';\n *\n * export function bindOwner<T>(fn: () => T): () => T {\n *   const owner = getOwner();\n *\n *   if (!owner) {\n *     throw new Error('No solidjs owner in current context');\n *   }\n *\n *   return () => runWithOwner(owner, fn);\n * }\n * ```\n */\nexport function bindOwner<T>(fn: () => T): () => T {\n  const owner = getOwner();\n\n  if (!owner) {\n    throw new Error('No solidjs owner in current context');\n  }\n\n  return () => runWithOwner(owner, fn);\n}\n","import type {\n  ValidatorFn,\n  ValidationErrors,\n  ControlId,\n  AbstractControlInterface,\n} from './abstract-control';\nimport { IAbstractControl } from './abstract-control';\nimport { produce, SetStoreFunction, Store } from 'solid-js/store';\nimport {\n  Accessor,\n  createComputed,\n  createMemo,\n  createSignal,\n  on,\n} from 'solid-js';\nimport { isEqual } from './util';\n\nexport const DEFAULT_SOURCE = 'CONTROL_DEFAULT_SOURCE';\n\nexport interface IAbstractControlBaseOptions<\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> {\n  id?: ControlId;\n  data?: Data;\n  disabled?: boolean;\n  touched?: boolean;\n  dirty?: boolean;\n  readonly?: boolean;\n  required?: boolean;\n  submitted?: boolean;\n  errors?: null | ValidationErrors | ReadonlyMap<ControlId, ValidationErrors>;\n  validators?:\n    | null\n    | ValidatorFn\n    | ValidatorFn[]\n    | ReadonlyMap<ControlId, ValidatorFn>;\n  pending?: boolean | ReadonlySet<ControlId>;\n}\n\nexport function propInitializer(): [\n  propInitializing: <T>(value: T) => T,\n  initComplete: () => void\n] {\n  const [initializationSignal, setInitializationSignal] = createSignal<\n    null | false\n  >(null);\n\n  return [\n    <T>(value: T) => initializationSignal() || value,\n    () => setInitializationSignal(false),\n  ];\n}\n\nexport function composeValidators(\n  validators: undefined | null | ValidatorFn | ValidatorFn[]\n): null | ValidatorFn {\n  if (!validators || (Array.isArray(validators) && validators.length === 0)) {\n    return null;\n  }\n\n  if (Array.isArray(validators)) {\n    return (control) =>\n      validators.reduce((prev: ValidationErrors | null, curr: ValidatorFn) => {\n        const errors = curr(control);\n        return errors ? { ...prev, ...errors } : prev;\n      }, null);\n  }\n\n  return validators;\n}\n\nexport type IAbstractControlBase<\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> = Omit<\n  IAbstractControl<unknown, Data, unknown>,\n  'value' | 'rawValue' | 'setValue' | typeof AbstractControlInterface\n>;\n\nlet controlId = 0;\n\nexport function createAbstractControlBase<\n  RawValue,\n  Data extends Record<ControlId, any> = Record<ControlId, any>,\n  Value = RawValue\n>(\n  store: Accessor<\n    [\n      Store<IAbstractControl<RawValue, Data, Value>>,\n      SetStoreFunction<IAbstractControl<RawValue, Data, Value>>\n    ]\n  >,\n  untilInit: <T>(value: T) => T,\n  initOptions: Pick<IAbstractControlBaseOptions<Data>, 'id' | 'data'> = {}\n): [base: IAbstractControlBase<Data>, initializer: () => void] {\n  let control: Store<IAbstractControl<RawValue, Data, Value>>;\n  let setControl: SetStoreFunction<IAbstractControl<RawValue, Data, Value>>;\n\n  let selfIsPendingMemo: Accessor<IAbstractControl['self']['isPending']>;\n  let selfErrorsMemo: Accessor<ValidationErrors | null>;\n  let statusMemo: Accessor<IAbstractControl['status']>;\n  let validatorMemo: Accessor<IAbstractControl['validator']>;\n\n  const base: IAbstractControlBase<Data> = {\n    id: initOptions.id || Symbol(`AbstractControl-${controlId++}`),\n\n    data: { ...(initOptions.data as Data) },\n\n    self: {\n      get isValid() {\n        // here \"this\" is self\n        return this.errors === null && !this.isPending;\n      },\n      isDisabled: false,\n      isTouched: false,\n      isDirty: false,\n      isReadonly: false,\n      isSubmitted: false,\n      isRequired: false,\n      get isPending() {\n        return selfIsPendingMemo?.() ?? untilInit(false);\n      },\n      get errors() {\n        return selfErrorsMemo?.() ?? untilInit(null);\n      },\n      errorsStore: new Map(),\n      pendingStore: new Set(),\n      validatorStore: new Map(),\n    },\n\n    get isDisabled() {\n      return this.self.isDisabled;\n    },\n\n    get isTouched() {\n      return this.self.isTouched;\n    },\n\n    get isDirty() {\n      return this.self.isDirty;\n    },\n\n    get isReadonly() {\n      return this.self.isReadonly;\n    },\n\n    get isSubmitted() {\n      return this.self.isSubmitted;\n    },\n\n    get isRequired() {\n      return this.self.isRequired;\n    },\n\n    get errors() {\n      return this.self.errors;\n    },\n\n    get isPending() {\n      return this.self.isPending;\n    },\n\n    get isValid() {\n      return this.self.isValid;\n    },\n\n    get status() {\n      return statusMemo?.() ?? untilInit('VALID');\n    },\n\n    get validator() {\n      return validatorMemo?.() ?? untilInit(null);\n    },\n\n    markDisabled(input) {\n      if (isEqual(this.self.isDisabled, input)) return;\n      setControl('self', 'isDisabled', input);\n    },\n\n    markReadonly(input) {\n      if (isEqual(this.self.isReadonly, input)) return;\n      setControl('self', 'isReadonly', input);\n    },\n\n    markRequired(input) {\n      if (isEqual(this.self.isRequired, input)) return;\n      setControl('self', 'isRequired', input);\n    },\n\n    markDirty(input) {\n      if (isEqual(this.self.isDirty, input)) return;\n      setControl('self', 'isDirty', input);\n    },\n\n    markTouched(input) {\n      if (isEqual(this.self.isTouched, input)) return;\n      setControl('self', 'isTouched', input);\n    },\n\n    markSubmitted(input) {\n      if (isEqual(this.self.isSubmitted, input)) return;\n      setControl('self', 'isSubmitted', input);\n    },\n\n    markPending(input, options) {\n      let newPendingStore: Set<ControlId>;\n\n      if (typeof input === 'boolean') {\n        const source = options?.source || DEFAULT_SOURCE;\n\n        if (this.self.pendingStore.has(source) === input) return;\n\n        newPendingStore = new Set(this.self.pendingStore);\n\n        if (input) {\n          newPendingStore.add(source);\n        } else {\n          newPendingStore.delete(source);\n        }\n      } else {\n        if (this.self.pendingStore === input) return;\n\n        newPendingStore = new Set(input);\n      }\n\n      if (isEqual(this.self.pendingStore, newPendingStore)) return;\n\n      // We're using `produce()` here because using the standard solid Store\n      // nested setter has some bugs (i.e.\n      // `setControl('self', 'pendingStore', newPendingStore)`). I think the\n      // bugs are isolated to object values, so, at the moment, I'm only using\n      // produce where the value is an object.\n      setControl(\n        produce((state) => {\n          (state.self.pendingStore as Set<ControlId>) = newPendingStore;\n        })\n      );\n    },\n\n    setErrors(input, options) {\n      const source = options?.source || DEFAULT_SOURCE;\n\n      const existingStore = this.self.errorsStore;\n\n      let newErrorsStore: Map<ControlId, ValidationErrors>;\n\n      if (input instanceof Map) {\n        newErrorsStore = input;\n      } else if (input === null || Object.keys(input).length === 0) {\n        newErrorsStore = new Map(existingStore);\n        newErrorsStore.delete(source);\n      } else {\n        newErrorsStore = new Map(existingStore).set(source, input);\n      }\n\n      if (isEqual(this.self.errorsStore, newErrorsStore)) return;\n\n      // We're using `produce()` here because using the standard solid Store\n      // nested setter has some bugs (i.e.\n      // `setControl('self', 'pendingStore', newPendingStore)`). I think the\n      // bugs are isolated to object values, so, at the moment, I'm only using\n      // produce where the value is an object.\n      setControl(\n        produce((state) => {\n          (state.self.errorsStore as Map<ControlId, ValidationErrors>) =\n            newErrorsStore;\n        })\n      );\n    },\n\n    patchErrors(input, options) {\n      const existingStore = this.self.errorsStore as Map<\n        ControlId,\n        ValidationErrors\n      >;\n\n      if (input instanceof Map) {\n        // We're using `produce()` here because using the standard solid Store\n        // nested setter has some bugs (i.e.\n        // `setControl('self', 'pendingStore', newPendingStore)`). I think the\n        // bugs are isolated to object values, so, at the moment, I'm only using\n        // produce where the value is an object.\n        setControl(\n          produce((state) => {\n            (state.self.errorsStore as Map<ControlId, ValidationErrors>) =\n              new Map([...existingStore, ...input]);\n          })\n        );\n      } else {\n        if (Object.keys(input).length === 0) return;\n\n        const source = options?.source || DEFAULT_SOURCE;\n\n        let newErrors: ValidationErrors = input;\n\n        let existingValue = existingStore.get(source);\n\n        if (existingValue) {\n          existingValue = { ...existingValue };\n\n          for (const [k, err] of Object.entries(newErrors)) {\n            if (err === null) {\n              delete existingValue![k];\n            } else {\n              existingValue![k] = err;\n            }\n          }\n\n          newErrors = existingValue;\n        } else {\n          const entries = Object.entries(newErrors).filter(\n            ([, v]) => v !== null\n          );\n\n          if (entries.length === 0) return;\n\n          newErrors = Object.fromEntries(entries);\n        }\n\n        const newErrorsStore = new Map(existingStore);\n\n        if (Object.keys(newErrors).length === 0) {\n          newErrorsStore.delete(source);\n        } else {\n          newErrorsStore.set(source, newErrors);\n        }\n\n        if (isEqual(this.self.errorsStore, newErrorsStore)) return;\n\n        // We're using `produce()` here because using the standard solid Store\n        // nested setter has some bugs (i.e.\n        // `setControl('self', 'pendingStore', newPendingStore)`). I think the\n        // bugs are isolated to object values, so, at the moment, I'm only using\n        // produce where the value is an object.\n        setControl(\n          produce((state) => {\n            (state.self.errorsStore as Map<ControlId, ValidationErrors>) =\n              newErrorsStore;\n          })\n        );\n      }\n    },\n\n    setValidators(input, options) {\n      const source = options?.source || DEFAULT_SOURCE;\n\n      let newValidatorsStore: Map<ControlId, ValidatorFn>;\n\n      if (input instanceof Map) {\n        newValidatorsStore = new Map(input);\n      } else {\n        newValidatorsStore = new Map(\n          this.self.validatorStore as Map<ControlId, ValidatorFn>\n        );\n\n        const newValidator = composeValidators(\n          input as Exclude<typeof input, ReadonlyMap<any, any>>\n        );\n\n        if (newValidator) {\n          newValidatorsStore.set(source, newValidator);\n        } else {\n          newValidatorsStore.delete(source);\n        }\n      }\n\n      if (isEqual(this.self.validatorStore, newValidatorsStore)) return;\n\n      // We're using `produce()` here because using the standard solid Store\n      // nested setter has some bugs (i.e.\n      // `setControl('self', 'pendingStore', newPendingStore)`). I think the\n      // bugs are isolated to object values, so, at the moment, I'm only using\n      // produce where the value is an object.\n      setControl(\n        produce((state) => {\n          (state.self.validatorStore as Map<ControlId, ValidatorFn<any>>) =\n            newValidatorsStore;\n        })\n      );\n    },\n\n    setData(key, input) {\n      if (isEqual(this.data[key], input)) return;\n      // We're using `produce()` here because using the standard solid Store\n      // nested setter has some bugs (i.e.\n      // `setControl('self', 'pendingStore', newPendingStore)`). I think the\n      // bugs are isolated to object values, so, at the moment, I'm only using\n      // produce where the value is an object.\n      setControl(\n        produce((state) => {\n          state.data[key] = input;\n        })\n      );\n    },\n  };\n\n  const initializer = () => {\n    [control, setControl] = store();\n\n    selfIsPendingMemo = createMemo(() => control.self.pendingStore.size > 0);\n\n    selfErrorsMemo = createMemo(() => {\n      return control.self.errorsStore.size === 0\n        ? null\n        : Array.from(\n            control.self.errorsStore.values()\n          ).reduce<ValidationErrors>(\n            (p, errors) => ({\n              ...p,\n              ...errors,\n            }),\n            {}\n          );\n    });\n\n    statusMemo = createMemo(() => {\n      return control.isDisabled\n        ? 'DISABLED'\n        : control.isPending\n        ? 'PENDING'\n        : control.isValid\n        ? 'VALID'\n        : 'INVALID';\n    });\n\n    validatorMemo = createMemo(() => {\n      if (control.self.validatorStore.size === 0) return null;\n\n      const validators = Array.from(control.self.validatorStore.values());\n\n      return (c) => {\n        const e = validators.reduce<ValidationErrors>((err, v) => {\n          return { ...err, ...v(c) };\n        }, {});\n\n        return Object.keys(e).length === 0 ? null : e;\n      };\n    });\n\n    // Intentionally not using `createRenderEffect()` since it appears to\n    // mess with initializing a control with errors (i.e. it clears the errors\n    // after the control is initialized)\n    createComputed(\n      on(\n        () => control.validator?.(control.rawValue) ?? null,\n        (errors) => {\n          if (control.self.errorsStore.get(DEFAULT_SOURCE) === errors) return;\n\n          const newErrorsStore = new Map(\n            control.self.errorsStore as Map<ControlId, ValidationErrors>\n          );\n\n          if (errors) {\n            newErrorsStore.set(DEFAULT_SOURCE, errors);\n          } else {\n            newErrorsStore.delete(DEFAULT_SOURCE);\n          }\n\n          if (isEqual(control.self.errorsStore, newErrorsStore)) return;\n\n          // We're using `produce()` here because using the standard solid Store\n          // nested setter has some bugs (i.e.\n          // `setControl('self', 'pendingStore', newPendingStore)`). I think the\n          // bugs are isolated to object values, so, at the moment, I'm only using\n          // produce where the value is an object.\n          setControl(\n            produce((state) => {\n              (state.self.errorsStore as Map<ControlId, ValidationErrors>) =\n                newErrorsStore;\n            })\n          );\n        }\n      )\n    );\n  };\n\n  return [base, initializer];\n}\n","import { createStore, produce, SetStoreFunction, Store } from 'solid-js/store';\nimport {\n  IAbstractControl,\n  ControlId,\n  AbstractControlInterface,\n  isAbstractControl,\n} from './abstract-control';\nimport {\n  IAbstractControlBaseOptions,\n  createAbstractControlBase,\n  propInitializer,\n} from './abstract-control-base';\nimport { isEqual, mergeObj } from './util';\n\nexport const FormControlInterface = '@@FormControlInterface_solidjs';\n\nexport interface IFormControlOptions<\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> extends IAbstractControlBaseOptions<Data> {}\n\nexport interface IFormControl<\n  Value = any,\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> extends IAbstractControl<Value, Data, Value> {\n  [FormControlInterface]: true;\n}\n\n/**\n * Returns true if the provided object implements\n * `IFormControl`\n */\nexport function isFormControl(object?: unknown): object is IFormControl {\n  return (\n    isAbstractControl(object) &&\n    (object as any)?.[FormControlInterface] === true\n  );\n}\n\nexport function createFormControl<\n  Value,\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n>(\n  value?: Value,\n  options?: IFormControlOptions<Data>\n): IFormControl<Value, Data>;\nexport function createFormControl<\n  Value,\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n>(\n  initValue?: Value,\n  initOptions: IFormControlOptions<Data> = {}\n): IFormControl<Value, Data> {\n  let control: Store<IFormControl<Value, Data>>;\n  let setControl: SetStoreFunction<IFormControl<Value, Data>>;\n\n  const [untilInit, initComplete] = propInitializer();\n\n  const [base, initializeBase] = createAbstractControlBase<Value, Data, Value>(\n    () => [control, setControl],\n    untilInit,\n    initOptions\n  );\n\n  const storeConfig = mergeObj(base, {\n    [AbstractControlInterface]: true,\n    [FormControlInterface]: true,\n\n    rawValue: initValue as Value,\n\n    get value() {\n      return this.rawValue;\n    },\n\n    setValue(value) {\n      if (isEqual(this.value, value)) return;\n\n      // We're using `produce()` here because using the standard solid Store\n      // nested setter has some bugs (i.e.\n      // `setControl('self', 'pendingStore', newPendingStore)`). I think the\n      // bugs are isolated to object values, so, at the moment, I'm only using\n      // produce where the value could be an object.\n      setControl(\n        produce((state) => {\n          (state.rawValue as Value) = value;\n        })\n      );\n    },\n  } as IFormControl<Value, Data>);\n\n  [control, setControl] = createStore<IFormControl<Value, Data>>(storeConfig);\n\n  initializeBase();\n  initComplete();\n\n  // Intentionally not using `batch()` since it appears to mess with\n  // initializing a control with errors\n  if (initOptions.disabled) control.markDisabled(initOptions.disabled);\n  if (initOptions.touched) control.markTouched(initOptions.touched);\n  if (initOptions.dirty) control.markDirty(initOptions.dirty);\n  if (initOptions.readonly) control.markReadonly(initOptions.readonly);\n  if (initOptions.submitted) control.markSubmitted(initOptions.submitted);\n  if (initOptions.required) control.markRequired(initOptions.required);\n  if (initOptions.pending) control.markPending(initOptions.pending);\n  if (initOptions.validators) control.setValidators(initOptions.validators);\n  if (initOptions.pending) control.markPending(initOptions.pending);\n  // this needs to be last to ensure that the errors aren't overwritten\n  if (initOptions.errors) control.patchErrors(initOptions.errors);\n\n  return control as unknown as IFormControl<Value, Data>;\n}\n","import {\n  AbstractControlInterface,\n  ControlId,\n  isAbstractControl,\n  ValidationErrors,\n} from './abstract-control';\n\nimport { IAbstractControl } from './abstract-control';\n\nimport {\n  AbstractControlContainerInterface,\n  ControlsKey,\n  ControlsRawValue,\n  ControlsValue,\n  GenericControlsObject,\n  isAbstractControlContainer,\n} from './abstract-control-container';\n\nimport { IAbstractControlContainer } from './abstract-control-container';\n\nimport {\n  createAbstractControlBase,\n  IAbstractControlBaseOptions,\n} from './abstract-control-base';\n\nimport { produce, SetStoreFunction, Store } from 'solid-js/store';\nimport { Accessor, batch, createMemo } from 'solid-js';\nimport { isEqual, mergeObj } from './util';\nimport type { PartialDeep } from 'type-fest';\n\nexport interface IAbstractControlContainerBaseArgs<\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> extends IAbstractControlBaseOptions<Data> {}\n\nexport interface IAbstractControlContainerBase<\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> extends Omit<\n    IAbstractControlContainer<any, Data>,\n    | 'value'\n    | 'rawValue'\n    | 'controls'\n    | 'setControl'\n    | typeof AbstractControlInterface\n    | typeof AbstractControlContainerInterface\n  > {}\n\nexport function createAbstractControlContainerBase<\n  Controls extends GenericControlsObject = any,\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n>(\n  store: Accessor<\n    [\n      Store<IAbstractControlContainer<Controls, Data>>,\n      SetStoreFunction<IAbstractControlContainer<Controls, Data>>\n    ]\n  >,\n  untilInit: <T>(value: T) => T,\n  initOptions: IAbstractControlContainerBaseArgs<Data> = {}\n): [base: IAbstractControlContainerBase<Data>, initializer: () => void] {\n  let control: Store<IAbstractControlContainer<Controls, Data>>;\n  let setControl: SetStoreFunction<IAbstractControlContainer<Controls, Data>>;\n\n  const [base, initializeAbstractControl] = createAbstractControlBase<\n    ControlsRawValue<Controls>,\n    Data,\n    ControlsValue<Controls>\n  >(() => [control, setControl], untilInit, initOptions);\n\n  let sizeMemo: Accessor<number>;\n\n  let childIsValidMemo: Accessor<boolean>;\n  let childIsDisabledMemo: Accessor<boolean>;\n  let childIsReadonlyMemo: Accessor<boolean>;\n  let childIsRequiredMemo: Accessor<boolean>;\n  let childIsPendingMemo: Accessor<boolean>;\n  let childIsTouchedMemo: Accessor<boolean>;\n  let childIsDirtyMemo: Accessor<boolean>;\n  let childIsSubmittedMemo: Accessor<boolean>;\n\n  let childrenAreValidMemo: Accessor<boolean>;\n  let childrenAreDisabledMemo: Accessor<boolean>;\n  let childrenAreReadonlyMemo: Accessor<boolean>;\n  let childrenAreRequiredMemo: Accessor<boolean>;\n  let childrenArePendingMemo: Accessor<boolean>;\n  let childrenAreTouchedMemo: Accessor<boolean>;\n  let childrenAreDirtyMemo: Accessor<boolean>;\n  let childrenAreSubmittedMemo: Accessor<boolean>;\n\n  let errorsMemo: Accessor<ValidationErrors | null>;\n  let childrenErrorsMemo: Accessor<ValidationErrors | null>;\n\n  const containerBase = mergeObj(base, {\n    get size() {\n      return sizeMemo?.() ?? untilInit(0);\n    },\n\n    get isDisabled() {\n      return this.self.isDisabled || this.children.areDisabled;\n    },\n\n    get isTouched() {\n      return this.self.isTouched || this.child.isTouched;\n    },\n\n    get isDirty() {\n      return this.self.isDirty || this.child.isDirty;\n    },\n\n    get isReadonly() {\n      return this.self.isReadonly || this.children.areReadonly;\n    },\n\n    get isSubmitted() {\n      return this.self.isSubmitted || this.children.areSubmitted;\n    },\n\n    get isRequired() {\n      return this.self.isRequired || this.child.isRequired;\n    },\n\n    get isPending() {\n      return this.self.isPending || this.child.isPending;\n    },\n\n    get errors() {\n      return errorsMemo?.() ?? untilInit(null);\n    },\n\n    get isValid() {\n      return this.self.isValid && this.children.areValid;\n    },\n\n    child: {\n      /** Will return true if *any* `enabled` direct child control is `valid` */\n      get isValid() {\n        return childIsValidMemo?.() ?? untilInit(true);\n      },\n      /** Will return true if *any* direct child control is `disabled` */\n      get isDisabled() {\n        return childIsDisabledMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *any* `enabled` direct child control is `readonly` */\n      get isReadonly() {\n        return childIsReadonlyMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *any* `enabled` direct child control is `required` */\n      get isRequired() {\n        return childIsRequiredMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *any* `enabled` direct child control is `pending` */\n      get isPending() {\n        return childIsPendingMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *any* `enabled` direct child control is `touched` */\n      get isTouched() {\n        return childIsTouchedMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *any* `enabled` direct child control is `dirty` */\n      get isDirty() {\n        return childIsDirtyMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *any* `enabled` direct child control is `submitted` */\n      get isSubmitted() {\n        return childIsSubmittedMemo?.() ?? untilInit(false);\n      },\n    },\n\n    children: {\n      /** Will return true if *all* `enabled` direct child control's are `valid` */\n      get areValid() {\n        return childrenAreValidMemo?.() ?? untilInit(true);\n      },\n      /** Will return true if *all* direct child control's are `disabled` */\n      get areDisabled() {\n        return childrenAreDisabledMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *all* `enabled` direct child control's are `readonly` */\n      get areReadonly() {\n        return childrenAreReadonlyMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *all* `enabled` direct child control's are `required` */\n      get areRequired() {\n        return childrenAreRequiredMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *all* `enabled` direct child control's are `pending` */\n      get arePending() {\n        return childrenArePendingMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *all* `enabled` direct child control's are `touched` */\n      get areTouched() {\n        return childrenAreTouchedMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *all* `enabled` direct child control's are `dirty` */\n      get areDirty() {\n        return childrenAreDirtyMemo?.() ?? untilInit(false);\n      },\n      /** Will return true if *all* `enabled` direct child control's are `submitted` */\n      get areSubmitted() {\n        return childrenAreSubmittedMemo?.() ?? untilInit(false);\n      },\n      /** Contains *all* `enabled` child control errors or `null` if there are none */\n      get errors() {\n        return childrenErrorsMemo?.() ?? untilInit(null);\n      },\n\n      markDirty(value, options) {\n        batch(() => {\n          Object.values(control.controls).forEach((c) => {\n            (c as IAbstractControl).markDirty(value);\n\n            if (!options?.deep || !isAbstractControlContainer(c)) {\n              return;\n            }\n\n            c.children.markDirty(value, options);\n          });\n        });\n      },\n\n      markDisabled(value, options) {\n        batch(() => {\n          Object.values(control.controls).forEach((c) => {\n            (c as IAbstractControl).markDisabled(value);\n\n            if (!options?.deep || !isAbstractControlContainer(c)) {\n              return;\n            }\n\n            c.children.markDisabled(value, options);\n          });\n        });\n      },\n\n      markPending(value, options) {\n        batch(() => {\n          Object.values(control.controls).forEach((c) => {\n            (c as IAbstractControl).markPending(value, options);\n\n            if (!options?.deep || !isAbstractControlContainer(c)) {\n              return;\n            }\n\n            c.children.markPending(value, options);\n          });\n        });\n      },\n\n      markReadonly(value, options) {\n        batch(() => {\n          Object.values(control.controls).forEach((c) => {\n            (c as IAbstractControl).markReadonly(value);\n\n            if (!options?.deep || !isAbstractControlContainer(c)) {\n              return;\n            }\n\n            c.children.markReadonly(value, options);\n          });\n        });\n      },\n\n      markRequired(value, options) {\n        batch(() => {\n          Object.values(control.controls).forEach((c) => {\n            (c as IAbstractControl).markRequired(value);\n\n            if (!options?.deep || !isAbstractControlContainer(c)) {\n              return;\n            }\n\n            c.children.markRequired(value, options);\n          });\n        });\n      },\n\n      markSubmitted(value, options) {\n        batch(() => {\n          Object.values(control.controls).forEach((c) => {\n            (c as IAbstractControl).markSubmitted(value);\n\n            if (!options?.deep || !isAbstractControlContainer(c)) {\n              return;\n            }\n\n            c.children.markSubmitted(value, options);\n          });\n        });\n      },\n\n      markTouched(value, options) {\n        batch(() => {\n          Object.values(control.controls).forEach((c) => {\n            (c as IAbstractControl).markTouched(value);\n\n            if (!options?.deep || !isAbstractControlContainer(c)) {\n              return;\n            }\n\n            c.children.markTouched(value, options);\n          });\n        });\n      },\n    },\n\n    setControls(controls: Controls) {\n      if (isEqual(control.controls, controls)) return;\n\n      // We're using `produce()` here because using the standard solid Store\n      // nested setter has some bugs (i.e.\n      // `setControl('self', 'pendingStore', newPendingStore)`). I think the\n      // bugs are isolated to object values, so, at the moment, I'm only using\n      // produce where the value is an object.\n      setControl(\n        produce((state) => {\n          (state.controls as Controls) = controls;\n        })\n      );\n    },\n\n    /**\n     * The provided control is removed from this FormGroup\n     * if it is a child of this FormGroup. Or the control\n     * associated with the provided key is removed.\n     */\n    removeControl(\n      keyOrControl: ControlsKey<Controls> | Controls[ControlsKey<Controls>]\n    ) {\n      if (!isAbstractControl(keyOrControl)) {\n        control.setControl(keyOrControl as ControlsKey<Controls>, null);\n        return;\n      }\n\n      const childControl = keyOrControl;\n\n      for (const [key, c] of Object.entries(control.controls!)) {\n        if (c !== childControl) continue;\n\n        control.setControl(key as ControlsKey<Controls>, null);\n        return;\n      }\n    },\n\n    setValue(value: ControlsRawValue<Controls>) {\n      const valueEntries = Object.entries(value);\n\n      if (valueEntries.length !== control.size!) {\n        throw new Error(\n          `setValue error: you must provide a value for each control.`\n        );\n      }\n\n      batch(() => {\n        for (const [key, val] of valueEntries) {\n          const c = control.controls[\n            key as ControlsKey<Controls>\n          ] as unknown as IAbstractControl | undefined;\n\n          if (!c) {\n            throw new Error(`Invalid setValue value key \"${key}\".`);\n          }\n\n          c.setValue(val);\n        }\n      });\n    },\n\n    patchValue(value: PartialDeep<ControlsRawValue<Controls>>) {\n      batch(() => {\n        for (const [key, entryValue] of Object.entries(value)) {\n          const c = control.controls[\n            key as ControlsKey<Controls>\n          ] as unknown as IAbstractControl | undefined;\n\n          if (!c) {\n            throw new Error(`Invalid patchValue value key \"${key}\".`);\n          }\n\n          if (isAbstractControlContainer(c)) {\n            c.patchValue(entryValue);\n          } else {\n            c.setValue(entryValue);\n          }\n        }\n      });\n    },\n  } as IAbstractControlContainerBase<Data>);\n\n  const initializer = () => {\n    [control, setControl] = store();\n\n    initializeAbstractControl();\n\n    const allControlsMemo = createMemo(() => Object.values(control.controls));\n\n    const nonDisabledControlsMemo = createMemo(() =>\n      allControlsMemo().filter((c) => !c.isDisabled)\n    );\n\n    sizeMemo = createMemo(() => allControlsMemo().length);\n\n    childIsValidMemo = createMemo(() =>\n      nonDisabledControlsMemo().some((c) => c.isValid)\n    );\n\n    childIsDisabledMemo = createMemo(() =>\n      allControlsMemo().some((c) => c.isDisabled)\n    );\n\n    childIsReadonlyMemo = createMemo(() =>\n      nonDisabledControlsMemo().some((c) => c.isReadonly)\n    );\n\n    childIsRequiredMemo = createMemo(() =>\n      nonDisabledControlsMemo().some((c) => c.isRequired)\n    );\n\n    childIsPendingMemo = createMemo(() =>\n      nonDisabledControlsMemo().some((c) => c.isPending)\n    );\n\n    childIsTouchedMemo = createMemo(() =>\n      nonDisabledControlsMemo().some((c) => c.isTouched)\n    );\n\n    childIsDirtyMemo = createMemo(() =>\n      nonDisabledControlsMemo().some((c) => c.isDirty)\n    );\n\n    childIsSubmittedMemo = createMemo(() =>\n      nonDisabledControlsMemo().some((c) => c.isSubmitted)\n    );\n\n    childrenAreValidMemo = createMemo(() =>\n      nonDisabledControlsMemo().every((c) => c.isValid)\n    );\n\n    childrenAreDisabledMemo = createMemo(() => {\n      const controls = allControlsMemo();\n\n      if (controls.length === 0) return false;\n\n      return controls.every((c) => c.isDisabled);\n    });\n\n    childrenAreReadonlyMemo = createMemo(() => {\n      const controls = nonDisabledControlsMemo();\n\n      if (controls.length === 0) return false;\n\n      return controls.every((c) => c.isReadonly);\n    });\n\n    childrenAreRequiredMemo = createMemo(() => {\n      const controls = nonDisabledControlsMemo();\n\n      if (controls.length === 0) return false;\n\n      return controls.every((c) => c.isRequired);\n    });\n\n    childrenArePendingMemo = createMemo(() => {\n      const controls = nonDisabledControlsMemo();\n\n      if (controls.length === 0) return false;\n\n      return controls.every((c) => c.isPending);\n    });\n\n    childrenAreTouchedMemo = createMemo(() => {\n      const controls = nonDisabledControlsMemo();\n\n      if (controls.length === 0) return false;\n\n      return controls.every((c) => c.isTouched);\n    });\n\n    childrenAreDirtyMemo = createMemo(() => {\n      const controls = nonDisabledControlsMemo();\n\n      if (controls.length === 0) return false;\n\n      return controls.every((c) => c.isDirty);\n    });\n\n    childrenAreSubmittedMemo = createMemo(() => {\n      const controls = nonDisabledControlsMemo();\n\n      if (controls.length === 0) return false;\n\n      return controls.every((c) => c.isSubmitted);\n    });\n\n    errorsMemo = createMemo(() => {\n      if (!control.self.errors && !control.children.errors) return null;\n\n      return {\n        ...control.children.errors,\n        ...control.self.errors,\n      };\n    });\n\n    childrenErrorsMemo = createMemo(() => {\n      const controls = nonDisabledControlsMemo();\n\n      return controls.reduce((prev, curr) => {\n        return prev === null && curr.errors === null\n          ? null\n          : { ...prev, ...curr.errors };\n      }, null as ValidationErrors | null);\n    });\n  };\n\n  return [containerBase, initializer];\n}\n","import {\n  AbstractControlInterface,\n  ControlId,\n  IAbstractControl,\n} from './abstract-control';\nimport { createAbstractControlContainerBase } from './abstract-control-container-base';\nimport {\n  ControlsValue,\n  ControlsRawValue,\n  ControlsKey,\n  IAbstractControlContainer,\n  AbstractControlContainerInterface,\n  isAbstractControlContainer,\n} from './abstract-control-container';\nimport {\n  IAbstractControlBaseOptions,\n  propInitializer,\n} from './abstract-control-base';\nimport { createStore, produce, SetStoreFunction, Store } from 'solid-js/store';\nimport { Accessor, createMemo } from 'solid-js';\nimport { isEqual, mergeObj } from './util';\nimport type { PartialDeep } from 'type-fest';\n\nexport const FormGroupInterface = '@@FormGroupInterface_solidjs';\n\nexport interface IFormGroupOptions<\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> extends IAbstractControlBaseOptions<Data> {}\n\nexport interface IFormGroup<\n  Controls extends { [key: string]: IAbstractControl } = {\n    [key: string]: IAbstractControl;\n  },\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> extends IAbstractControlContainer<Controls, Data> {\n  [FormGroupInterface]: true;\n  setControls(controls: Controls): void;\n  removeControl(\n    keyOrControl: ControlsKey<Controls> | Controls[ControlsKey<Controls>]\n  ): void;\n  patchValue(value: PartialDeep<ControlsRawValue<Controls>>): void;\n}\n\n/**\n * Returns true if the provided object implements\n * `IFormGroup`\n */\nexport function isFormGroup(object?: unknown): object is IFormGroup {\n  return (\n    isAbstractControlContainer(object) &&\n    (object as any)?.[FormGroupInterface] === true\n  );\n}\n\nexport function createFormGroup<\n  Controls extends { [key: string]: IAbstractControl } = {\n    [key: string]: IAbstractControl;\n  },\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n>(\n  controls?: Controls,\n  options?: IFormGroupOptions<Data>\n): IFormGroup<Controls, Data>;\nexport function createFormGroup<\n  Controls extends { [key: string]: IAbstractControl } = {\n    [key: string]: IAbstractControl;\n  },\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n>(\n  initControls = {} as Controls,\n  initOptions: IFormGroupOptions<Data> = {}\n): IFormGroup<Controls, Data> {\n  let control: Store<IFormGroup<Controls, Data>>;\n  let setControl: SetStoreFunction<IFormGroup<Controls, Data>>;\n\n  const [untilInit, initComplete] = propInitializer();\n\n  const [base, initializeBase] = createAbstractControlContainerBase(\n    () => [control, setControl],\n    untilInit,\n    initOptions\n  );\n\n  let rawValueMemo: Accessor<ControlsRawValue<Controls>>;\n  let valueMemo: Accessor<ControlsValue<Controls>>;\n\n  const storeConfig = mergeObj(base, {\n    [AbstractControlInterface]: true,\n    [AbstractControlContainerInterface]: true,\n    [FormGroupInterface]: true,\n\n    controls: initControls,\n\n    get rawValue() {\n      return rawValueMemo?.() ?? untilInit({});\n    },\n\n    get value() {\n      return valueMemo?.() ?? untilInit({});\n    },\n\n    setControl<N extends ControlsKey<Controls>>(\n      key: N,\n      newControl: Controls[N] | null\n    ) {\n      if (\n        newControl === null\n          ? !control.controls[key]\n          : isEqual(control.controls[key], newControl)\n      ) {\n        return;\n      }\n\n      setControl(\n        produce((state) => {\n          if (newControl === null) {\n            delete state.controls[key];\n          } else {\n            state.controls[key] = newControl;\n          }\n        })\n      );\n    },\n  } as IFormGroup<Controls, Data>);\n\n  [control, setControl] = createStore(storeConfig);\n\n  initializeBase();\n\n  const allControlEntriesMemo = createMemo(() =>\n    Object.entries(control.controls)\n  );\n\n  const enabledControlEntriesMemo = createMemo(() =>\n    allControlEntriesMemo().filter(([, c]) => !c.isDisabled)\n  );\n\n  rawValueMemo = createMemo(\n    () =>\n      Object.fromEntries(\n        allControlEntriesMemo().map(([k, c]) => [k, c.rawValue])\n      ) as ControlsRawValue<Controls>\n  );\n\n  valueMemo = createMemo(\n    () =>\n      Object.fromEntries(\n        enabledControlEntriesMemo().map(([k, c]) => [k, c.value])\n      ) as ControlsValue<Controls>\n  );\n\n  initComplete();\n\n  // Intentionally not using `batch()` since it appears to mess with\n  // initializing a control with errors\n  if (initOptions.disabled) control.markDisabled(initOptions.disabled);\n  if (initOptions.touched) control.markTouched(initOptions.touched);\n  if (initOptions.dirty) control.markDirty(initOptions.dirty);\n  if (initOptions.readonly) control.markReadonly(initOptions.readonly);\n  if (initOptions.submitted) control.markSubmitted(initOptions.submitted);\n  if (initOptions.required) control.markRequired(initOptions.required);\n  if (initOptions.pending) control.markPending(initOptions.pending);\n  if (initOptions.validators) control.setValidators(initOptions.validators);\n  if (initOptions.pending) control.markPending(initOptions.pending);\n  // this needs to be last to ensure that the errors aren't overwritten\n  if (initOptions.errors) control.patchErrors(initOptions.errors);\n\n  return control as unknown as IFormGroup<Controls, Data>;\n}\n","import {\n  AbstractControlInterface,\n  ControlId,\n  IAbstractControl,\n} from './abstract-control';\nimport { createAbstractControlContainerBase } from './abstract-control-container-base';\nimport {\n  ControlsValue,\n  ControlsRawValue,\n  ControlsKey,\n  IAbstractControlContainer,\n  AbstractControlContainerInterface,\n  isAbstractControlContainer,\n} from './abstract-control-container';\nimport {\n  IAbstractControlBaseOptions,\n  propInitializer,\n} from './abstract-control-base';\nimport { createStore, produce, SetStoreFunction, Store } from 'solid-js/store';\nimport { Accessor, batch, createMemo } from 'solid-js';\nimport { isEqual, mergeObj } from './util';\nimport type { PartialDeep } from 'type-fest';\n\nexport const FormArrayInterface = '@@FormArrayInterface_solidjs';\n\nexport interface IFormArrayOptions<\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> extends IAbstractControlBaseOptions<Data> {}\n\nexport interface IFormArray<\n  Controls extends ReadonlyArray<IAbstractControl> = ReadonlyArray<IAbstractControl>,\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n> extends IAbstractControlContainer<Controls, Data> {\n  [FormArrayInterface]: true;\n  push(control: Controls[number]): void;\n  setControls(controls: Controls): void;\n  removeControl(\n    keyOrControl: ControlsKey<Controls> | Controls[ControlsKey<Controls>]\n  ): void;\n  patchValue(value: PartialDeep<ControlsRawValue<Controls>>): void;\n}\n\n/**\n * Returns true if the provided object implements\n * `IFormArray`\n */\nexport function isFormArray(object?: unknown): object is IFormArray {\n  return (\n    isAbstractControlContainer(object) &&\n    (object as any)?.[FormArrayInterface] === true\n  );\n}\n\nexport function createFormArray<\n  Controls extends ReadonlyArray<IAbstractControl> = ReadonlyArray<IAbstractControl>,\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n>(\n  controls?: Controls,\n  options?: IFormArrayOptions<Data>\n): IFormArray<Controls, Data>;\nexport function createFormArray<\n  Controls extends ReadonlyArray<IAbstractControl> = ReadonlyArray<IAbstractControl>,\n  Data extends Record<ControlId, any> = Record<ControlId, any>\n>(\n  initControls = [] as unknown as Controls,\n  initOptions: IFormArrayOptions<Data> = {}\n): IFormArray<Controls, Data> {\n  let control: Store<IFormArray<Controls, Data>>;\n  let setControl: SetStoreFunction<IFormArray<Controls, Data>>;\n\n  const [untilInit, initComplete] = propInitializer();\n\n  const [base, initializeBase] = createAbstractControlContainerBase(\n    () => [control, setControl],\n    untilInit,\n    initOptions\n  );\n\n  let rawValueMemo: Accessor<ControlsRawValue<Controls>>;\n  let valueMemo: Accessor<ControlsValue<Controls>>;\n\n  const storeConfig = mergeObj(base, {\n    [AbstractControlInterface]: true,\n    [AbstractControlContainerInterface]: true,\n    [FormArrayInterface]: true,\n\n    controls: initControls,\n\n    get rawValue() {\n      return rawValueMemo?.() ?? untilInit({});\n    },\n\n    get value() {\n      return valueMemo?.() ?? untilInit({});\n    },\n\n    setControl<N extends ControlsKey<Controls>>(\n      key: N,\n      newControl: Controls[N] | null\n    ) {\n      if (\n        newControl === null\n          ? !control.controls[key]\n          : isEqual(control.controls[key], newControl)\n      ) {\n        return;\n      }\n\n      setControl(\n        produce((state) => {\n          if (newControl === null) {\n            (\n              state.controls as unknown as Array<\n                typeof state['controls'][number]\n              >\n            ).splice(key, 1);\n          } else {\n            state.controls[key] = newControl;\n          }\n        })\n      );\n    },\n\n    push(control: Controls[number]) {\n      this.setControl(this.controls.length, control);\n    },\n  } as IFormArray<Controls, Data>);\n\n  [control, setControl] = createStore(storeConfig);\n\n  initializeBase();\n\n  const enabledControlsMemo = createMemo(() =>\n    control.controls.filter((c) => !c.isDisabled)\n  );\n\n  rawValueMemo = createMemo(\n    () =>\n      (control as IFormArray<Controls, Data>).controls.map(\n        (c) => c.rawValue\n      ) as unknown as ControlsRawValue<Controls>\n  );\n\n  valueMemo = createMemo(\n    () =>\n      enabledControlsMemo().map(\n        (c) => c.value\n      ) as unknown as ControlsValue<Controls>\n  );\n\n  initComplete();\n\n  // Intentionally not using `batch()` since it appears to mess with\n  // initializing a control with errors\n  if (initOptions.disabled) control.markDisabled(initOptions.disabled);\n  if (initOptions.touched) control.markTouched(initOptions.touched);\n  if (initOptions.dirty) control.markDirty(initOptions.dirty);\n  if (initOptions.readonly) control.markReadonly(initOptions.readonly);\n  if (initOptions.submitted) control.markSubmitted(initOptions.submitted);\n  if (initOptions.required) control.markRequired(initOptions.required);\n  if (initOptions.pending) control.markPending(initOptions.pending);\n  if (initOptions.validators) control.setValidators(initOptions.validators);\n  if (initOptions.pending) control.markPending(initOptions.pending);\n  // this needs to be last to ensure that the errors aren't overwritten\n  if (initOptions.errors) control.patchErrors(initOptions.errors);\n\n  return control as unknown as IFormArray<Controls, Data>;\n}\n"],"names":["AbstractControlInterface","isAbstractControl","object","AbstractControlContainerInterface","isAbstractControlContainer","isEqual","a","b","_isEqual","mergeObj","Object","defineProperties","getOwnPropertyDescriptors","bindOwner","fn","owner","getOwner","Error","runWithOwner","DEFAULT_SOURCE","propInitializer","createSignal","initializationSignal","setInitializationSignal","value","composeValidators","validators","Array","isArray","length","control","reduce","prev","curr","errors","controlId","createAbstractControlBase","store","untilInit","initOptions","setControl","selfIsPendingMemo","selfErrorsMemo","statusMemo","validatorMemo","base","id","Symbol","data","self","isValid","isPending","isDisabled","isTouched","isDirty","isReadonly","isSubmitted","isRequired","errorsStore","Map","pendingStore","Set","validatorStore","status","validator","markDisabled","input","markReadonly","markRequired","markDirty","markTouched","markSubmitted","markPending","options","newPendingStore","source","has","add","produce","state","setErrors","existingStore","newErrorsStore","keys","set","patchErrors","newErrors","existingValue","get","_objectSpread","entries","k","err","filter","v","fromEntries","setValidators","newValidatorsStore","newValidator","setData","key","initializer","createMemo","size","from","values","p","c","e","createComputed","on","rawValue","FormControlInterface","isFormControl","createFormControl","initValue","initComplete","initializeBase","storeConfig","createStore","disabled","touched","dirty","readonly","submitted","required","pending","createAbstractControlContainerBase","initializeAbstractControl","sizeMemo","childIsValidMemo","childIsDisabledMemo","childIsReadonlyMemo","childIsRequiredMemo","childIsPendingMemo","childIsTouchedMemo","childIsDirtyMemo","childIsSubmittedMemo","childrenAreValidMemo","childrenAreDisabledMemo","childrenAreReadonlyMemo","childrenAreRequiredMemo","childrenArePendingMemo","childrenAreTouchedMemo","childrenAreDirtyMemo","childrenAreSubmittedMemo","errorsMemo","childrenErrorsMemo","containerBase","children","areDisabled","child","areReadonly","areSubmitted","areValid","areRequired","arePending","areTouched","areDirty","batch","controls","forEach","deep","setControls","removeControl","keyOrControl","childControl","setValue","valueEntries","val","patchValue","entryValue","allControlsMemo","nonDisabledControlsMemo","some","every","FormGroupInterface","isFormGroup","createFormGroup","initControls","rawValueMemo","valueMemo","newControl","allControlEntriesMemo","enabledControlEntriesMemo","map","FormArrayInterface","isFormArray","createFormArray","splice","enabledControlsMemo"],"mappings":"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"}
\ No newline at end of file
diff --git a/package.json b/package.json
index 1104ff2b5bc114949538da49c00c396e86e71e59..8ee080d11d7feaad25a5eb8cd86c566886c63fad 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,7 @@
 {
   "name": "solid-forms",
   "version": "0.5.2",
+  "type": "module",
   "description": "A Solidjs library for working with forms.",
   "license": "Unlicense",
   "sideEffects": false,
@@ -16,7 +17,7 @@
     "solid-js": "^1.4.0"
   },
   "dependencies": {
-    "fast-deep-equal": "^3.1.0"
+    "deep-equal": "^2.2.3"
   },
   "devDependencies": {
     "@babel/core": "^7.18.2",
